# 1. 运输层概述

## 1. 作用

计算机网络体系结构中的**物理层**、**数据链路层**以及**网络层**它们共同解决了**将主机通过异构网络互联**起来所面临的问题，**实现了主机到主机的通信**。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程.而运输层协议为运行在不同主机上的**应用进程之间**提供了**逻辑通信**

## 2. 端口号

运行在计算机上的进程使用进程标识符 PID 来标志,不同操作系统的 PID 格式不统一,为了使不同操作系统的程序能进行网络通信,需要有统一的方法对 TCP/IP 体系的应用程序进行标识,而运输层的端口号就是用来区分不同的应用程序.

- 端口号用16bit 表示,取值范围0~65535
  - 熟知端口号: 0~1023，IANA把这些端口号指派给了 TCP/IP 体系中最重要的一些应用协议，例如: F**TP**
    **使用21/20，HTTP使用80，DNS使用53。**
  - 登记端口号: 1024~49151,为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定
    的手续登记，以防止重复。例如: Microsoft RDP微软远程桌面使用的端口是3389。
  - 短暂端口号: 49152~65535, 留给**客户进程选择暂时使用**。当服务器进程收到客户进程的报文时，就知
    道了客户进程所使用的动态端口号。通信结束后,这个端口号可供其他客户进程以后使用。

![image-20220714185813253](assets\image-20220714185813253.png)

## 3. 一次首页数据的获取: 去看5.2节

# 2. TCP 和 UDP 比较

**用户数据报协议(User Datagram Protocol) 传输控制协议(Transmission Control Protocol)**

1. UDP 无连接, TCP 面向连接

   - UDP **无需连接**直接发送数据 , **UDP 支持单播,多播,广播**

   - TCP 通过**三次握手建立连接**    **TCP 支持单播**

2. UDP 面向报文,TCP面向字节流

   - UDP 面向应用报文,不会拆分或合并应用层传下来的报文.

   - TCP 并**不知道字节流的含义**,将字节流**编号存储**在**发送缓存**中,根据发送策略从发送缓存中提取一定数量的字节构建TCP 报文段并发送.接收方TCP从接收到的报文段中**取出数据载荷**部分并**存储在接收缓存**中,将部分字节交付给应用进程,不保证接收方与发送方数据块有对应大小关系

     面向字节流是TCP实现可靠传输,流量控制,拥塞控制的基础

3. 可靠性
   - UDP 会进行错误校验,出错后丢弃
   - TCP 提供面向连接的可靠传输服务

4. 数据报对比

   ![image-20220714195311399](assets\image-20220714195311399.png)

# 3. TCP 流量控制

如果发送方将数据发送的过快,接收方可能来不及接收数据,这就可能造成数据的丢失

流量控制(flow control)就是**让发送方的发送速率不要太快,让接收方来得及接收**

利用**滑动窗口**机制实现流量控制

- 最大段: 滑动窗口每一格的字节数

- 发送窗口: 大小为 min{自身拥塞窗口,接收窗口}

- 接收窗口

  利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。

  - TCP 接收方利用自己的**接收窗口**的大小来**限制**发送方**发送窗口**的大小。

  - TCP 发送方收到接收方的**零窗口通知**后，应启动**持续计时器**。持续计时器超时后，向接收方发送**零窗口探测报文**。

## 视频演示

https://www.bilibili.com/video/BV1c4411d7jb?p=60&vd_source=12e3c819d2ff8aacb84cbdeb6225e5ef

# 4. TCP 拥塞控制

在某段时间，若对网络中**某一资源的需求超过了该资源所能提供的可用部分**，网络性能就要变坏。这种情况就叫做**拥塞(congestion)**。

在计算机网络中的**链路容量(即带宽)**、**交换结点中的缓存和处理机**等,**都是网络的资源**。

若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。

![image-20220714203038301](assets\image-20220714203038301.png)

## 拥塞控制算法

**假定数据单方向传送,接收方有足够大的空间(发送窗口仅由拥塞程度决定),以最大报文段MSS个数为单位**

- 发送方维护一个叫**拥塞窗口(cwnd)**的状态变量,其值**取决于网络的拥塞程度**,并且**动态变化**
  - 只要网络**没有出现拥塞**,拥塞窗口就再**增大**一些,但只要网络**拥塞**,就拥塞**窗口就减小**一些
  - **发生超时重传**,即没有按时收到确认报文时,判定为**发生拥塞**

- **慢开始** : **开始**向网络**注入**的报文段少,并不是指拥塞窗口cwnd增长慢
- **拥塞避免** : 并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按**线性规律增长**，使网络**比较不容易出现拥塞**;
- **快重传**
- **快恢复**

### 1. 慢开始和拥塞避免

维护一个慢开始门限 ssthresh 状态变量

- 当 cwnd < ssthresh时，使用慢开始算法;
- 当 cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法;
- 当 cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。

### 2. 快重传和快恢复

- 有时，**个别报文段**会在网络中**丢失**，但实际上网络**并未发生拥塞**。
  - 这将导致发送方**超时重传**， 并**误认为**网络发生了**拥塞**;
  - **发送方把拥塞窗口cwnd又设置为最小值1**,并错误地启动慢开始算法，因而**降低了传输效率**。

- 采用快重传算法可以**让发送方尽早知道个别报文段的丢失**
- 快重传算法首先要求接收方每**收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。
  - 要求接收方不要等待发送数据时才确认,而是**立即发送确认**
  - 即使收到失序报文段也要立即发出对已收到的报文段的**重复确认**
  - 发送方**收到三个连续的重复确认**,就将相应报文段进行**立即重传(快重传),快恢复(ssthresh更新为1/2,更新cwnd为ssthresh值)**,而不是等该报文段超时计时器超时重传

![image-20220714212311024](assets\image-20220714212311024.png)

# 5. 超时重传时间的选择

<img src="assets\image-20220714214353297.png" alt="image-20220714214353297" style="zoom:50%;" />

- 往返时间 RTT0
  - 如果超时重传时间 RTO 小于 RTT0 会造成不必要的重传
  - 如果超时重传时间 RTO 远大于RTT0 会使网络空闲时间增大,降低传输效率 

- **不能直接使用某次测量得到的 RTT 样本来计算超时重传时间 RTO**

## 利用每次测量得到的 RTT样本 

**RTO = RTTs + 4 * RTTD**

- **计算加权平均往返时间 RTTs (又称为平滑的往返时间)。**
  - **RTTs1 = RTT1** 
  - **新的RTTs = (1 - a) * RTTs + a * 新的 RTT 样本**
    - 在上式中，0≤a<l:
    - 若0很接近于 0, 则新 RTT 样本对 RTTs 的影响不大;
    - 若a很接近于 1, 则新 RTT 样本对 RTTs 的影响较大;
  - **已成为建议标准的 RFC6298 推荐的a值为1/8，即 0.125。**
    - 用这种方法得出的加权平均往返时间 RTTs 就比测量出的 RTT 值更加平滑。

- **计算偏差的加权平均 RTTD**
  - **RTTD1 = RTT1 / 2**
  - **新的 RTTD = (1 - b) * 旧的RTTD + b * |RTTs - 新 RTT 样本|**
    - 0≤ b <1
    - **已成为建议标准的RFC6298推荐的 b 值为1/4，即0.25。**

- **超时重传时 RTT 无法准确测量问题**, Karn 算法的做法是超时重传后不进行超时重传时间的更新,这会有一些问题,即如果时延突然增大,导致往返时间比原来的超时重传时间大,就会产生很多超时重传,但是根据Karn算法,超时重传时间此时不会进行更新,就会导致很多重传发生.所以要进行改进: 即**发生一次超时重传直接让新RTO等于旧RTO的两倍**

![image-20220715142512822](assets\image-20220715142512822.png)

# 6. TCP 的可靠传输

视频:

https://www.bilibili.com/video/BV1c4411d7jb?p=63&spm_id_from=pageDriver&vd_source=12e3c819d2ff8aacb84cbdeb6225e5ef

TCP 基于**以字节为单位的滑动窗口**来实现可靠传输

![image-20220715151434841](assets\image-20220715151434841.png)



## TCP 滑动窗口特点

- 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的**发送窗口并不总是和接收方的接收窗口一样大**。
  - 网络传送窗口值需要经历一定的**时间滞后**，并且这个时间还是不确定的。
  - 发送方还可能根据网络当时的**拥塞情况**适当减小自 己的发送窗口尺寸。
- 对于**不按序到达的数据应如何处理**，TCP并无明确规定。
  - 如果接收方把不按序到达的数据一律丟弃， 那么接收窗口的管理将会比较简单,但这样做对网络资源的利用不利,因为发送方会重复传送较多的数据。
  - TCP**通常**对不按序到达的数据是先**临时存放在接收窗口中**， 等到字节流中所缺少的字节**收到后**，再按序**交付上层**的应用进程。
- TCP要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。
  - **接收方不应过分推迟发送确认**， 否则会导致发送方不必要的超时重传,这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段,则必须每隔一个报文段就发送一个确认[RFC 1122]。
  - 捎带确认实际 上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。
- **TCP的通信是全双工通信**。通信中的每一-方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。
- **TCP 的 ACK 是接收方希望收到的下一个字节的序号**

## **GBN SR TCP 关系总结** 

### 区别：

**GBN**

- 如果某个报文段没有被正确接收，则从这个报文段到后面的报文段都要重新发送。
- 采用**累计应答**的方式。例如接收端返回ACK=3，则证明报文段3以及之前的报文段都被正确接收。
- 这里顺便解释一下为什么GBN可以采用累计应答的方式？怎么就能保证3之前的被正确接收了呢？这还要由GBN的工作机制来决定：在GBN机制下，在接收端的运输层一次只交付给上层一个分组，并且保证是按序交付的，因此如果分组k已接收，则所有序号小于k的分组也已经交付了。
- 接收端不对失序到达的分组进行缓存。

**SR**

- 接收方设置缓存区，用于接收失序到达的分组。（从这里可以感受到，所谓的**GBN中的发送端窗口**和**SR中的发送端与接收端的窗口**其实就是缓存区，用于缓存分组。注意，由于GBN是单个分组交付，不设置缓存区，所以GBN的接收端是没有窗口的）
- 为每个报文段设置单独的计时器，单个分组计时器超时只重发这一个报文段。
- 接收端返回ACK是当前接收成功报文段的序号，**SR不采用累计应答的方式。**

**TCP**

- TCP使用**累计应答(例如接收端返回ACK=3，则证明报文段3以及之前的报文段都被正确接收。)**的方式。这一点与GBN类似。
- TCP在接收端会**设置缓存，来缓存正确接收但是失序的分组**，这点与 SR 类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）
- TCP使用**快速重传机制**：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。
- 注意：TCP 中的 **ACK 是指接收端希望从发送端收到的下一字节的序号**。例如发送端发送了编号为0-5的字节，这时接收端成功接收后就会发送ACK为6。
- 注意：这里介绍的TCP这是理论上的，在实际使用过程中，大家加入了很多其他的机制等。目前计网学习的都是基础理论的知识。

# 7. TCP 的运输连接管理

- TCP 是面向连接的协议,它基于运输连接来传送 TCP 报文段
- TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程

1. 建立 TCP 连接 (三报文握手建立 TCP 连接)
2. 数据传送
3. 释放连接(四报文挥手释放 TCP 连接)

## 1. TCP 连接的建立

1. 建立连接要解决的问题
   - 使TCP双方能够确知对方的存在;
   - 使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等) ;
   - 使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配。

![image-20220715163849298](assets\image-20220715163849298.png)

## 2. TCP 的连接释放

![image-20220715185634296](assets\image-20220715185634296.png)

为什么要有时间等待?

直接关闭连接,如果确认关闭报文传输过程中丢失,服务器会一直超时重发连接释放报文

![image-20220715185717079](assets\image-20220715185717079.png)

### 保活计时器

![image-20220715185918146](assets\image-20220715185918146.png)

- TCP服务器进程**每收到一次TCP客户进程的数据**，就**重新设置并启动保活计时器**(2小时定时)。
- 若**保活计时器定时周期内未收到TCP客户进程发来的数据**，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个**探测报文段**，以后则**每隔75秒钟发送一次**。若**一连发送10个探测报文段后仍无TCP客户进程的响应**，TCP服务器进程就认为TCP客户进程所在主机出了故障,接着就**关闭这个连接**。

# 8. TCP 首部格式

- 为了实现可靠传输，TCP采用了**面向字节流**的方式。
- 但TCP在发送数据时，是**从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送**。
  - 一个TCP报文段由**首部**和**数据载荷**两部分构成;
  - **TCP的全部功能都体现在它首部中各字段的作用。**

![image-20220715191555933](assets\image-20220715191555933.png)

- **源端口** : 16 bit,写入源端口号,用来标识发送该TCP 报文段的应用进程

- **目的端口** : 16 bit,写入目的端口号,用来标识接收该TCP 报文段的应用进程

  

------



- **序号(seq)** : 32 bit 范围(0 ~ 2^32 -1) ,序号增加到最后一个后,又从零开始

  - **指出本TCP 报文段数据载荷的第一个字节的序号**

    ![image-20220715193319158](assets\image-20220715193319158.png)

  - 

- **确认号(ack)** : 32 bit 范围(0 ~ 2^32 -1) ,序号增加到最后一个后,又从零开始

  - **指出期望收到对方下一-个TCP报文段的数据载荷的第一个字节的序号， 同时也是对之前收到的所有数据的确认。**
  - 若确认号为n,表示序号到n-1为止的所有数据都已经正确接收,希望接收序号位n的数据

- **确认标志位 ACK** : 取值为1是确认号字段才有效

  - **TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。**



------



- **数据偏移** :  4 bit,并以4字节为单位

  - **用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远**

  - **这个字段实际上是指出了TCP报文段的首部长度。**

    - 首部固定长度为20字节，因此数据偏移字段的最小值为(0101)2   --> 5 * 4字节(4字节为单位) = 20字节

    - 首部最大长度为60字节, 因此数据偏移字段最大值为(1111)2 --> 15 * 4 = 60字节

      

------



- **保留** : 6 bit,保留今后使用,目前置为零



------



- **窗口** : 16bit, 以字节为单位,**指出发出本报文段的一方的接收窗口**
  - **窗口值作为接收方让发送方设置其发送窗口的依据**。
  - 这是**以接收方的接收能力来控制发送方的发送能力**，称为**流量控制**。



------



- **校验和** : 16 bit,检查范围包括 TCP 报文段的首部和数据载荷两部分
  - 在计算校验和时,要在TCP 报文段前面加上12字节的伪首部



------



- **SYN** : 在TCP建立时同步序号



- **FIN** : 用来释放TCP连接



------



- **复位标志位 RST** : 用来复位TCP连接

  - **当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。**

  - **RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接**

    

- **推送标志位 PSH** :  接收方的TCP收到该标志位为1的报文段会**尽快上交应用进程**，而不必等到接收缓存都填满后再向.上交付。



------



- **紧急标志位 URG** : 取值为1时紧急指针字段有效;取值为0时紧急指针字段无效。

- **紧急指针** : 占16比特，以字节为单位，用来指明紧急数据的长度。
  - 当发送方有紧急数据时，可将紧急数据**插队到发送缓存的最前面**，并**立刻封装到一个TCP报文段中进行发送**。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。



------



- **选项(可变长度)** 
  - **最大报文段长度 MSS 选项**: TCP报文段数据载荷部分的最大长度。
  - **窗口扩大选项**:为了扩大窗口(提高吞吐率)
  - **时间戳选项**:
    - 用来计算往返时间RTT
    - 用于处理序号超范围的情况，又称为防止序号绕回PAWS。
  - **选择确认选项**

- **填充** : 
- 由于**选项的长度可变**，因此使用填充来**确保报文段首部能被4整除**
  (**因为数据偏移字段，也就是首部长度字段，是以4字节为单位的**)

