## 理论基础

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

debug: 

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？



## 斐波那契数列

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/fibonacci-number

>下标为 i 的数组元素表示第 i 个斐波那契数列值, 地推公式: f(n) = f(n-1) + f(n-2);



代码:

```java
    public int fib(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n - 1];
    }
```



## 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```



来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/climbing-stairs

> dp[i]： 爬到第i层楼梯，有dp[i]种方法, 递推公式:  f(n) = f(n-1) + f(n-2); ::上第 i 个楼梯可以从i-1 台阶上一步,或者从 i-2 台阶上两步,就这两种方式, 那么上第 i 个台阶的的方法数就是 i-1 和 i-2 台阶上去方法之和



代码:

```java
    public int climbStairs(int n) {
        if (n <= 1) return n;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
```



## 上楼梯的最小花费

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

- ```
  输入：cost = [10,15,20]
  输出：15
  解释：你将从下标为 1 的台阶开始。
  
  - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
    总花费为 15 。
  ```

  

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/min-cost-climbing-stairs



> 可以从第 0 个或第 1 个台阶开始爬, dp[i] 表示到第 i 个楼梯的最小花费, 
>
> `f(n) = Math.min(f(n-1) + cost(n-1), f(n-2) + cost(n-2))` 



代码:

```java
    public int minCostClimbingStairs(int[] cost) {
        // dp[i] 表示上到第 i 个台阶的最小花费
        int[] dp = new int[cost.length + 1];
        // 题目说明可以从0/1开始爬楼梯,初始可以在0/1
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[cost.length];
    }
```



## 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/unique-paths

> 机器人到达每个格子只能从上面或者左边来,那么到 dp[i] [j] 格的方法就是 dp[i-1] [j] + dp[i] [j-1], 最顶层只能有一种方法,最左边也只能有一种方法, f(m,n) = f(m-1,n)+f(m,n-1)



代码:

```java
    public int uniquePaths(int m, int n) {
        int[][] path = new int[m][n];
        for (int i = 0; i < m; i++) {
            path[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            path[0][i] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                path[i][j] = path[i - 1][j] + path[i][j - 1];
            }
        }

        return path[m - 1][n - 1];
    }
```



## 不同路径II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/unique-paths-ii

> 在不同路径上加了障碍物,障碍物无法到达所以其 dp[i] = 0; 
>
> f(m,n) = {f(n-1,m) + f(n,m-1) / 0} 
>
> 方程可以不变因为当后面有障碍物时dp[i-1] [j] = 0,相加不影响
>
> 同时第一行/列的初始值也要改变,如果有障碍物的话后面全为0



代码:

```java
        public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            if (obstacleGrid[i][0] == 1) break;
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            if (obstacleGrid[0][i] == 1) break;
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
```



## 整数拆分

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

示例 1:

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/integer-break

> dp[i] 表示将整数 i 拆分后乘积的最大值,i 可以 拆分成 j+(i-j) <1 <= j < i >,j和i-j也可以继续拆分,那么就有三种情况,直接相乘: j*i-j 拆一个: j * dp[i-j] 拆两个: dp[j] * dp[i-j]
>
> 初始化 dp[1] = 1,dp[2] = 1
>
> 递推公式: f(n) =  max(j*n-i, j * f(i-j), f(i)*f(i-j)) 



代码:

```java
    public int integerBreak(int n) {

        // dp[i] 表示把数字 i 拆分后能得到的最大值
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                // 分为 j*i-j , j*dp[i-j], dp[j]*dp[i-j] 三种情况
                dp[i] = Math.max(Math.max(Math.max(dp[j] * dp[i - j], j * dp[i - j]), j * (i - j)), dp[i]);
            }
        }

        return dp[n];
    }
```

优化:

```java
     public int integerBreak(int n) {
        //dp[i] 为正整数 i 拆分后的结果的最大乘积
        int[]dp=new int[n+1];
        dp[2]=1;
        for(int i=3;i<=n;i++){
            for(int j=1;j<=i-j;j++){
                // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，
                //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，
                //j 最大到 i-j,就不会用到 dp[0]与dp[1]
                dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。
            }
        }
        return dp[n];
    }
```



## 不同的二叉搜索树

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

```
示例 1：
输入：n = 3
输出：5

示例 2：
输入：n = 1
输出：1
```



来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/unique-binary-search-trees
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



> 从 1 到 n 的二叉搜索树,它是什么形状的? 当这颗树头结点为 1 时,它的左子树没有结点,右子树有n-2个结点,头结点为 2 的二叉搜索树,左子树有 1 个结点,右子树有 n-2 个结点,那么它们的左子树有多少中形式呢?就是dp[i]种,因为它的左子树结点就是 1 ~ i-1 ,那右子树形态呢?其实也就是 n-i 种,因为右子树是从 i+1 ~ n ,也是有序的,那么它和从 i+1-i  ~ n-i  = 1 ~ n-i的结点是可以等价的,即为dp[n-i],那么 dp[n] = dp[0]*dp[n-1] + dp[1] * dp[n-2] + ... + dp[n-1] * dp[0];即为递推公式



代码:

```java
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            // 左子树数量从 0 增加到 i-1,右子树数量从 i-1 到 0,这一过程代表了头结点从 1 到 n 的树的形态,头结点为1时,左子树为0个,右子树i-1个
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - 1 - j];
            }
        }

        return dp[n];
    }

```



## 01 背包基础

val = {val1, val2, val3, val4}, 物品 i~n 的价值

weight = {w1, w2, w3, w4} 物品 i~n 的重量

allWeight = W 背包总容量

> dp[i]\[j] 代表可以放 i 个物品,背包容量为 j 的时候,最大价值为多少
>
> 将问题分解为是否放第 i 个物品,如果不放第 i 个物品,那么 dp[i]\[j] = dp[i-1]\[j] 即就是放 i-1 个物品背包容量为 j 时的最大价值.
>
> 如果放第 i 个物品, dp[i]\[j] = max(dp[i-1]\[j], dp[i-1]\[j - weight[i]] + value[i])
>
> dp[i-1]\[j - weight[i]] 为背包容量为 j-weight[i] 不放物品 i 时的最大价值



代码:

```java
    public int knapsack() {
        int[] val = new int[]{1, 2, 3};
        int[] weight = new int[]{1, 2, 3};
        int allUp = 4;
        int[][] dp = new int[val.length + 1][allUp + 1];

        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j <= allUp; j++) {
                // 要不要放第 i 个物品
                // 判断能不能放得下
                if (j >= weight[i - 1]) {//这里减一是因为weight数组里第一个物品的下标是0
                    // 如果放的下,判断放与不放那个价值更大
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + val[i - 1]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }

        }

        return dp[val.length][allUp];
    }

```

`优化为一维 dp 数组,从递推公式中可以发现,dp[i][j] 无非是从 dp[i-1][*] 里面选值,就是在上一层里面选,我们可以考虑覆盖,只要从后往前遍历背包容量,前面的就是二维中的上一层的数据,并且这层数据只会用到当前列之前的数据,所以倒序遍历刚合适(从前往后遍历的话dp[i-1]已经被覆盖掉了) `

代码:

```java


   for (int i = 1; i <= val.length; i++) {
       // 背包重量为 j 能放 i 个数时,背包的最大价值
       for (int j = bag; j >= nums[i-1]; j--) {  
            dp[j] = Math.max(dp[j], dp[j - nums[i - 1]] + nums[i - 1]);
       }
   }

```



## 分割等和子集

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

示例 1：

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/partition-equal-subset-sum

> 首先这道题用回溯算法会超时,不能用回溯
>
> 两个子集元素和相等,那他们的元素和肯定为 sum/2,那么只要找到一个子集的和为 sum/2 ,那另一个必定;也相同,因为总和为sum.
>
> 用背包问题思考: 将背包总容量看做 k,物品的重量和价值都是 nums[i], 背包容量是 k,能放下的最大价值就是k,求最大价值后 dp[bagSize] == bagSize,返回 true



代码:

```java
    public boolean canPartition(int[] nums) {
        int total = 0;
        for (int num : nums) {
            total += num;
        }
        if ((total & 1) != 0) return false;
        int bag = total / 2;

        // 背包重量为 j 时,背包的最大价值
        int[] dp = new int[bag + 1];
        dp[0] = 0;

        for (int i = 1; i <= nums.length; i++) {
            // 背包重量为 j 能放 i 个数时,背包的最大价值
            for (int j = bag; j >= 0; j--) {
                if (j >= nums[i - 1]) {
                    dp[j] = Math.max(dp[j], dp[j - nums[i - 1]] + nums[i - 1]);
                }
            }
        }

        return dp[bag] == bag;
    }
```



## 最后一块石头的重量II

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/last-stone-weight-ii

> 将石块分成两堆尽量相同重量的石块,撞击后留下的就是最轻重量
> 转换为背包问题就是将石块对半分,最大重量为 temp = wieght / 2, 求得在最大重量为temp的情况下能放石块的最大重量是多少



代码:

```java
    public int lastStoneWeightII(int[] stones) {
        int weight = 0;
        for (int i = 0; i < stones.length; i++) {
            weight += stones[i];
        }
        //
        int temp = weight >> 1;
        int[] dp = new int[temp + 1];
        // dp[j] : 背包容量为 j 的情况下最多能容纳的最大重量
        for (int i = 1; i <= stones.length; i++) {
            for (int j = temp; j >= 0; j--) {
                if (j >= stones[i - 1]) {
                    dp[j] = Math.max(dp[j], dp[j - stones[i - 1]] + stones[i - 1]);
                }
            }
        }
        return weight - dp[temp] - dp[temp];
    }

```



## 目标和

难度中等1412收藏分享切换为英文接收动态反馈

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。



> ```
> // 转换,将加减问题转换为加问题或者减问题
> // 运算结果为 target ,那么把加得数看做一个集合,减得数看做一个集合
> // 就有集合a - 集合b = target
> // 问题就变成了求集合a
> // 集合a - 集合b = target, 集合a + 集合b = sum
> // 集合a = sum - 集合a + target ==> 集合a = (sum + target)/2
> ```

>         // dp 数组的含义是充满背包容量为 j 的方法有多少种
>         // dp[j] 表示背包容量为 j 时把背包充满的方法数,假设当前要填充的数为 nums[i]
>         // 如果要放它进背包,那就看 dp[j - nums[i]] 是多少种
>         // 即就是将容量为 j - nums[i]的背包充满有多少种方法
>         // 如果不把当前数让进背包,那就看dp[j]本身,本身代表有 i-1 个数时把背包放满有多少种方法
>         结果就是不放的话 dp[i]\[j] = dp[i-1]\[j](在这之前有多少种方法能充满). 放的话 dp\[i][j] = dp\[i-1][j]\(在这之前能充满的方法数) + dp[i-1]\[j-w[i]](把它放进去能充满的方法数)
>         区别是放入的话这里不再是选大小,而是我都要,算总数

```java
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if (sum < target) return 0;
        int nt = sum + target;

        if (nt < 0) return 0;
        if ((nt & 1) != 0) return 0;

        int temp = nt / 2;

        int[] dp = new int[temp + 1];
        dp[0] = 1;

        for (int i = 1; i <= nums.length; i++) {
            for (int j = temp; j >= 0; j--) {
                if (j >= nums[i - 1]) {
                    // dp[]
                    dp[j] = dp[j] + dp[j - nums[i - 1]];
                } else {
                    dp[j] = dp[j];// 便于理解
                }
            }
        }

        return dp[temp];
    }
```

`把背包充满有多少种方法: dp[j] += dp[j - nums[i]]`

## 完全背包基础

val = {val1, val2, val3, val4}, 物品 i~n 的价值

weight = {w1, w2, w3, w4} 物品 i~n 的重量

allWeight = W 背包总容量

`和0,1背包不同的是,每一件物品都可以无限放`

> dp[i]\[j] 表示背包容量为 j 时的最大价值
>
> 遍历到第 i 个物品,背包容量为 j 时,和0,1背包一样要考虑放或者不放
>
> 如果不放第 i 个物品,和0,1背包一样 dp[i]\[j] = dp[i-1]\[j]
>
> 如果要放第 i 个物品的话就和 0,1 背包不同了,因为物品可以放多个,在容量为 j 时放入第 i 个物品,它的价值为 dp[i]\[j-w[i]] 和 0,1 背包不同的是这里是 `dp[i][j-w[i]]` 而不是 `dp[i-1][j-w[i]]`,因为每个物品是无限放的,放了第 i 个物品还可以放第 i 个物品,所以是 i 不是 i-1.



代码:

```java
for(int i = 1; i <= val.length; i++){
   for(int j = 1; j <= allWeight; j++){
      if(j >= weight[i-1]){
         //改动就是 dp[i][j-weightp[i-1]]
         dp[i][j] = Math.max(dp[i-1][j], dp[i][j-weight[i-1]] + val[i-1])
      } else{
          dp[i][j] = dp[i-1][j];
      }
   }
}
```



`优化为一维数组,但必须从前往后遍历,也是因为 dp[i][j-weight[i-1]] 的原因,需要用到同一列前面的数据`

```java
for(int i = 1; i <= val.length; i++){
   for(int j = 1; j <= allWeight; j++){
      if(j >= weight[i-1]){
         //改动就是 dp[i][j-weightp[i-1]]
         dp[j] = Math.max( dp[j], dp[ j - weight[i-1] ] + val[i - 1]);
      }   
   }
}
```



## 零钱兑换II

[518]

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。

题目数据保证结果符合 32 位带符号整数。



**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```



> 求得是有多少种方法,面额还有无限个,是完全背包问题.



```java
    public int change(int amount, int[] coins) {

        // dp[j] 表示要凑成总金额为 j 的硬币组合数有多少种
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 1; i <= coins.length; i++) {
            // 倒序遍历的话就是0,1背包,每一行不会覆盖前面的值,只能放一个时的情况
            for (int j = 1; j <= amount; j++) {
                if (j >= coins[i - 1]) {
                    // 没放它之前能充满的方法数 + 放它的话能充满的方法数
                    dp[j] += dp[j - coins[i - 1]];
                }
            }
        }
        return dp[amount];
    }

```



## 组合总和 Ⅳ

[377]

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/combination-sum-iv

> 和上一题一样都是完全背包求情况数,但是这里求得是排列不是集合
>
> `当固定背包遍历元素的时候,每一个元素都能出现在任意位置,才不会漏掉排列`
>
> `当固定元素,遍历背包的时候,后一个元素只能出现在前一个元素的后面`



代码:

```java
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int j = 1; j <= target; j++) {
            for (int i = coins[i-1]; i <= nums.length; i++) {
                  dp[j] += dp[j - nums[i - 1]];
            }
        }
        return dp[target];
    }
```





## 零钱兑换

[322]

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。



**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

> dp[j] 表示背包容量为 j 时所需的最少硬币个数,考虑放或不放的问题,
>
> 放的所需个数为 dp[j-coins[i-1]] + 1 `(dp[i][j-coins[i-1]] + 1) 放的话考虑当前行,和0,1背包的区别`
>
> 不放所需个数为 dp[j] `(dp[i-1][j]) 不放的话考虑当前列`
>
> 那么 dp[j] = Math.min(dp[j], dp[j-coins[i-1]] + 1);
>
> 这里要初始化数组元素为 maxvalue,再使dp[0] = 0; 



代码:

```java
    public int coinChange(int[] coins, int amount) {
        if (amount == 0) return 0;
        // dp[j] 为凑成总金额为 j 所需的最少硬币个数
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= coins.length; i++) {
            for (int j = coins[i - 1]; j <= amount; j++) {
                if (dp[j - coins[i - 1]] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - coins[i - 1]] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }

```



## 完全平方数

[279]

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 

示例 1：

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/perfect-squares

> 翻译: 1~n 的完全平方数是物品, n 是背包容量,求放满背包最小物品数
>
> 好,和上一题一样了



代码:

```java
    public int numSquares(int n) {
        if(isTrue(n)) return 1;
        // dp[j] 表示和为 j 的完全平方数的最少数量
        int[] dp = new int[n + 1];
        int max = Integer.MAX_VALUE;
        for (int i = 0; i <= n; i++) {
            dp[i] = max;
        }
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            if (!isTrue(i)) continue;
            for (int j = i; j <= n; j++) {
                // 当前行有满足条件的项再去比大小,否则继承上一行
                if (dp[j - i] != max) {
                    dp[j] = Math.min(dp[j], dp[j - i] + 1);
                }
            }
        }

        return dp[n];
    }

     public boolean isTrue(int n) {
        int temp = (int) Math.sqrt(n);
        return temp * temp == n;
    }
```



## 单词拆分

[139]

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```



> s 作为背包, wordDict 里的字符串作为物品
>
> wordDict[i] 是否放入背包(dp[j] 如果为 true 的话不用放, 放的话判断是否相等)
>
> 放入的话 dp[j] = dp[j - wordDict[i].length()]
>
> 先遍历背包,因为求得是排列



代码:

```java
    public boolean wordBreak(String s, List<String> wordDict) {
        // dp[j] 表示字符串长度为 j 时能不能由字典中字符串组成
        // dp[j] = dp[j - wordDict.get(i-1).length()]
        boolean[] dp = new boolean[s.length() + 1];
        // 长度为零的时候可以组成
        dp[0] = true;
        for (int j = 1; j <= s.length(); j++) {
            for (int i = 1; i <= wordDict.size(); i++) {
                String dict = wordDict.get(i - 1);
                if (j < dict.length() || dp[j] == true) continue;
                // 当前物品能不能放进背包
                if (dict.equals(s.substring(j - dict.length(), j))) {
                    dp[j] = dp[j - dict.length()];
                }
            }
        }

        return dp[s.length()];
    }

```



## 多重背包

在0,1背包的基础上增加了每个物品不止1个,但是是限定数量的可是:

和如下情况有区别么？

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

没错,它就变成了0,1背包,每个物品只用一次,在0,1背包的里面加一个for遍历每个物品的个数就成了多重背包

```java
    for(int i = 0; i < weight.length; i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
    }
```



## 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/house-robber

> dp[i] 表示从 0~i 户房屋最多可以偷窃的金额
>
> 如果进入当前房屋 dp[i] = dp[i-2] + nums[i]
>
> 如果不进入当前房屋 dp[i] = dp[i-1]
>
> dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1])
>
> 初始化 dp[0] = 0; dp[1] = max(dp[0], dp[1])



代码:

```java
    public int rob(int[] nums) {
        if (nums.length == 1){
            return nums[0];
        }
        // 偷窃 i 个房屋能拿到的最高金额
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }

        return dp[nums.length - 1];
    }

```



## 打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/house-robber-ii

> 和打家劫舍不同的是成环了,要考虑最后一个元素和第一个元素冲突问题
>
> 打劫最后的结果要么不包含第一个元素,要么不包含最后一个元素,分别求两次
>
> 求两次打家劫舍的情况(0,length-1) 和 (1,length)



代码:

```java
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        if (nums.length == 1) {
            return nums[0];
        }
        return Math.max(rob(nums, 0, nums.length - 1),
                rob(nums, 1, nums.length));
    }


    public int rob(int[] nums, int start, int end) {
        if (end - start == 1) {
            return nums[start];
        }
        // 偷窃 i 个房屋能拿到的最高金额
        int[] dp = new int[end - start];
        dp[0] = nums[start];
        dp[1] = Math.max(nums[start], nums[start + 1]);
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[start + i], dp[i - 1]);
        }

        return dp[dp.length - 1];
    }
```



## 打家劫舍III







## 买股票的最佳时机

[121]

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

> 找最便宜的一天买,最贵的一天卖; 维护两个值 minPrice 和 maxProfit,遍历数组并更新



代码:

```java
    class Solution {
        public int maxProfit(int[] prices) {
            if (prices.length == 1 || prices.length == 0){
                return 0;
            }
            int minPrice = Integer.MAX_VALUE;
            int maxProfit = Integer.MIN_VALUE;
            for (int i = 0; i < prices.length; i++) {
                // 前 i 天的最小价格
                if (prices[i] < minPrice) {
                    minPrice = prices[i];
                }
                // 最大利润
                if (prices[i] - minPrice > maxProfit) {
                    maxProfit = prices[i] - minPrice;
                }
            }

            return maxProfit;
        }
    }

```



## 买股票的最佳时机II

[122]

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii

> dp[i]\[0] 表示第 i 天持有股票时拥有的最大现金 ==> 上一天不持有股票今天买 或 上一天持有股票 
>
> dp[i]\[1] 表示第 i 天不持有股票时能获得的最大利润 ==> 上一天持有股票今天卖掉 或 上一天不持有股票



代码:

```java
        public int maxProfit(int[] prices) {
            if (prices.length == 0 || prices.length == 1) return 0;
            // dp[i][0] 表示在第 i 天持有股票
            // dp[i][1] 表示在第 i 天不持有股票
            int[][] dp = new int[prices.length][2];
            dp[0][0] = -prices[0];
            dp[0][1] = 0;
            for (int i = 1; i < prices.length; i++) {
                // 第 i 天持有股票所得现金
                // dp[i - 1][1] - prices[i] ==> 用目前的现金去买股票
                // dp[i - 1][0] 上一题持有股票拥有的现金
                // 拿着股票还持有更多现金说明那天的股票便宜
                // 当昨天不持有股票今天买了之后能拿到的钱比昨天持有的多时,就买
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
                // 第 i 天不持有股票的最大利润
                // dp[i - 1][0] + prices[i] ==> 在今天卖掉后拥有的现金
                // dp[i-1][1] ==> 前一天不持有股票所拥有的现金
                dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
            }

            return dp[dp.length - 1][1];
        }

```



## 买股票的最佳时机III

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 2 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv

> ```
> // dp[i][0] 无操作
> // dp[i][1] 第一次买入
> // dp[i][2] 第一次卖出
> // dp[i][3] 第二次买入
> // dp[i][4] 第二次卖出
> 
>  //操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]
>  //操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]
>  
>  // 第 i 天卖出股票了
>  // 第 i 天没卖,延续前一天没卖的操作
> ```



代码:

```java
        public int maxProfit(int[] prices) {
            // dp[i][0] 无操作
            // dp[i][1] 第一次买入过且第 i 天持有股票
            // dp[i][2] 第一次卖出过且第 i 天不持有股票
            // dp[i][3] 第二次买入过且第 i 天持有股票
            // dp[i][4] 第二次卖出过且第 i 天不持有股票
            int[][] dp = new int[prices.length][5];
            dp[0][1] = -prices[0];
            dp[0][3] = -prices[0];
            for (int i = 1; i < prices.length; i++) {
                //操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]
                //操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]
                dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
                // 第 i 天卖出股票了
                // 第 i 天没卖,延续前一天没卖的操作
                dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
                // 第 i 天第二次买入操作(如果要买入,需要有前一天的第一次卖出状态,不买的话延续前一天状态)
                dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3]);
                // 第 i 天第二次卖出操作(如果卖的话前一天需要有买入状态,如果不卖的话延续前一天状态)
                dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4]);
            }
            return dp[prices.length - 1][4];
        }

```



## 买股票的最佳时机IV

[188]

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv

> 本质和上一题相同,在设置第 i 天的第 j 的状态时,需要考虑到第 i-1 天的第 j-1 个状态
>
> 即考虑第 i 天的第 j 次买入状态,需要考虑第 i-1 天的第 j-1 次卖出状态



代码:

```java
        public int maxProfit(int k, int[] prices) {
            if (prices.length == 0 || prices.length == 1) return 0;
            int[][] dp = new int[prices.length][2 * k + 1];
            for (int i = 1; i < 2 * k + 1; i += 2) {
                dp[0][i] = -prices[0];
            }

            for (int i = 1; i < prices.length; i++) {
                for (int j = 1; j < 2 * k + 1; j += 2) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]);
                    dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] + prices[i]);
                }
            }

            return dp[prices.length - 1][2 * k];
        }

```



## 买股票的最佳时机带冷冻期

[309]

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown

> dp[i]\[0] 第 i 天持有股票
>
> dp[i]\[1] 第 i 天不持有股票 & 不在冷冻期
>
> dp[i]\[2] 第 i 天不持有股票 & 在冷冻期
>
> 持有股票的前一天 ===> 已经持有 or 不在冷冻期
>
> 不持有在冷冻期 ===> 前一天持有 & 卖掉
>
> 不持有不在冷冻期 ===> 前一天在冷冻期 or 前一天就不在冷冻期



代码:

```java
        public int maxProfit(int[] prices) {
            if (prices.length == 0 || prices.length == 1) return 0;
            // 0: 当前持有股票最大利润
            // 1: 当前不持有股票 & 不在冷冻 期最大利润
            // 2: 当前不持有股票 & 在冷冻期 最大利润
            int[][] dp = new int[prices.length][3];
            dp[0][0] = -prices[0];
            for (int i = 1; i < prices.length; i++) {
                // 买股票说明昨天不是冷冻期
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
                // 不在冷冻期,昨天是冷冻期或者之前就不再是冷冻期
                // 这里转为不在冷冻期只能由冷冻期装来,不是由i-1持有股票转来,持有股票只能转向冷冻期
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]);
                // 在冷冻期说明昨天刚卖掉
                dp[i][2] = dp[i - 1][0] + prices[i];
            }

            return Math.max(dp[prices.length - 1][1],dp[prices.length - 1][2]);
        }

```



## 买股票的最佳时机带手续费

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown



> dp[i]\[0] 第 i 天持有股票的最大利润
>
> dp[i]\[1] 第 i 天不持有股票的最大利润
>
> 买股票时多减一个手续费即可



代码:

```java
        public int maxProfit(int[] prices, int fee) {
            if (prices.length == 0 || prices.length == 1) return 0;

            // dp[i][0] 当前持有股票的最大利润
            // dp[i][1] 当前不持有股票的最大利润
            /*int[][] dp = new int[prices.length][2];*/
            //空间优化
            // dp[0] 当前持有股票的最大利润
            // dp[1] 当前不持有股票的最大利润
            int[] dp = new int[2];

          /*  dp[0][0] = -prices[0] - fee;
            for (int i = 1; i < prices.length; i++) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            }*/

            dp[0] = -prices[0] - fee;
            for (int i = 1; i < prices.length; i++) {
                dp[0] = Math.max(dp[0], dp[1] - prices[i] - fee);
                dp[1] = Math.max(dp[1], dp[0] + prices[i]);
            }

            return dp[1];
        }

```



## 最长上升子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-increasing-subsequence

> dp[i] 表示以 nums[i] 为结尾的最长上升子序列
>
> 遍历 nums[j] ∈ 0~i-1 如果小于 nums[i] 则 dp[i] = max(dp[i], dp[j] + 1)
>
> dp[i] 初始值为 1,即只有它一个数
>
> 从所有dp中选一个最大的即可



代码:

```java
        public int lengthOfLIS(int[] nums) {
            // dp[i] 表示以 nums[i] 为结尾的最长上升子序列长度
            int[] dp = new int[nums.length];
            Arrays.fill(dp, 1);
            int maxLen = 1;
            for (int i = 1; i < nums.length; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j]) {
                        dp[i] = Math.max(dp[j] + 1, dp[i]);
                    }
                }
                maxLen = Math.max(maxLen, dp[i]);
            }
            return maxLen;
        }

```



## 最长连续递增子序列

[300]

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence

> 贪心: 递增就 count++ 否则 count = 1
>
> 动态规划: dp[i] 表示 nums[i] 结尾的最大连续递增子序列, 只需要判断和 nums[i-1] 的关系即可



代码:

```java
    //贪心
	public int findLengthOfLCIS(int[] nums) {
            int maxLen = 1;
            int len = 1;
            for (int i = 1; i < nums.length; i++) {
                if (nums[i] > nums[i - 1]) {
                    len++;
                } else {
                    len = 1;
                }
                maxLen = Math.max(len, maxLen);
            }
            return maxLen;
     }
     // 动态规划
     public int findLengthOfLCIS(int[] nums) {
            int[] dp = new int[nums.length];
            Arrays.fill(dp, 1);
            int max = 1;
            for (int i = 1; i < nums.length; i++) {
                if (nums[i] > nums[i - 1]) {
                    dp[i] = dp[i - 1] + 1;
                }
                max = Math.max(max, dp[i]);
            }

            return max;
     }
```



## 最长重复子数组

[718]

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。



**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 
```



> 子数组需要要一模一样
>
> dp[i]\[j] 表示 nums1 0~i , nums2 0~j ,以i,j结尾的最大相同子数组
>
> 如果 nums1[i] = nums2[j] 那么最大相同子数组就加一(在 i-1,j-1 的基础上)



代码:

```java
        public int findLength(int[] nums1, int[] nums2) {
            // dp[i] ===> 0-i 的最长公共子数组
            int[][] dp = new int[nums1.length + 1][nums2.length + 1];
            int max = 0;
            for (int i = 1; i <= nums1.length; i++) {
                for (int j = 1; j <= nums2.length; j++) {
                    if (nums1[i - 1] == nums2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    }
                    max = Math.max(max, dp[i][j]);
                }

            }
            return max;
        }

```



## 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-common-subsequence

> dp[i]\[j] 表示text1 从0-i text2 从0-j 的最大公共子序列
>
> 当 text1[i] = text2[j] 时, dp[i]\[j] = dp[i-1]\[j-1] + 1
>
> 否则 dp[i]\[j] = max(dp[i]\[j-1], dp[i-1]\[j])



| dp[i-1]\[j-1] | dp[i-1]\[j] |
| ------------- | ----------- |
| dp[i]\[j-1]   | dp[i]\[j]   |

代码:

```java
        public int longestCommonSubsequence(String text1, String text2) {
            //
            int[][] dp = new int[text1.length() + 1][text2.length() + 1];
            for (int i = 1; i <= text1.length(); i++) {
                for (int j = 1; j <= text2.length(); j++) {
                    if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    }
                }
            }
            return dp[text1.length()][text2.length()];
        }

```



## 不相交的线

[1035]

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

- `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。



> 这道题其实就是求最长公共子序列,不能相交就是序列顺序要一样
>
> 和上一道题一模一样



代码:

```java
        public int maxUncrossedLines(int[] nums1, int[] nums2) {
            // dp[i][j] 表示 nums1 -> 0-i,nums2 0-j 最大不相交数
            int[][] dp = new int[nums1.length + 1][nums2.length + 1];
            for (int i = 1; i <= nums1.length; i++) {
                for (int j = 1; j <= nums2.length; j++) {
                    if (nums1[i - 1] == nums2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                    }
                }
            }
            return dp[nums1.length][nums2.length];
        }

```





## 最大子序和

[53]

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。



> 贪心: 当和小于零时,对后续无积极影响
>
> 动态规划: 这里的和由子序组成,因为是要连续的子数组,那么我们在定义dp数组的时候,它的定义就应该为以 i **结尾**的最大子序和
>
> `像是带有上升,连续,或者能看出是需要有序才能完成的题目,需要以 i 为结尾`



代码:

```java
        public int maxSubArray(int[] nums) {
            // dp[i] 表示以i结尾的最大自序和
            int[] dp = new int[nums.length];
            dp[0] = nums[0];
            int max = dp[0];
            for (int i = 1; i < nums.length; i++) {
                dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
                max = Math.max(max, dp[i]);
            }

            return max;
        }

```



## 判断子序列

[392]

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/is-subsequence

> 双指针可以很快
>
> 动态规划: dp[i]\[j] 表示 s以 s[i]结尾, t以 t[j] 结尾的相同子序列的长度
>
> 如果 s[i] == s[j], dp[i]\[j] = dp[i-1]\[j-1] + 1; 如果不相等的话理论上是删除 t[j],那当前dp就等于 dp[i]\[j-1] 了,最后判断以最后一个t[j] 结尾的子序列长度是否等于s的长度即可



代码:

```java
        public boolean isSubsequence(String s, String t) {
            // dp[i][j] s从0-i t从0-j的
            int[][] dp = new int[s.length() + 1][t.length() + 1];
            for (int i = 1; i <= s.length(); i++) {
                for (int j = 1; j <= t.length(); j++) {
                    if (s.charAt(i - 1) == t.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = dp[i][j - 1];
                    }
                }
            }

            return dp[s.length()][t.length()] == s.length();
        }

```



## 不同的子序列

[115]

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

**示例 1：**

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
```



> dp[i]\[j] 表示以 i 为结尾的s中出现的以j为结尾的t的次数
> 当s[i] = t[j] 时,dp[i]\[j] 肯定能由dp[i-1]\[j-1]得到,但是不用s[i]有可能也能组成s,所以还要加上 dp[i-1]\[j]
> 初始化 dp[i]\[0] = 1,因为组成空的字符串把自己全删掉就好



代码:

```java
        public int numDistinct(String s, String t) {
            // dp[i][j] 以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
            int[][] dp = new int[s.length() + 1][t.length() + 1];
            for (int i = 0; i < dp.length; i++) {
                dp[i][0] = 1;
            }
            for (int i = 1; i <= s.length(); i++) {
                for (int j = 1; j <= t.length(); j++) {
                    if (s.charAt(i - 1) == t.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                }
            }

            return dp[s.length()][t.length()];
        }

```



## 两个字符串的删除操作

[583]

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

 

> 动态规划: 
>
> 1.求最大公共子序列
>
> 2.删除逻辑,dp[i]\[j] 以i,j 为结尾



删除逻辑:

```java
        public int minDistance(String word1, String word2) {
            int[][] dp = new int[word1.length() + 1][word2.length() + 1];
            for (int i = 0; i < dp.length; i++) {
                dp[i][0] = i;
            }
            for (int i = 0; i < dp[0].length; i++) {
                dp[0][i] = i;
            }
            
            for (int i = 1; i <= word1.length(); i++) {
                for (int j = 1; j <= word2.length(); j++) {
                    if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        //删 w1 + 1 or 删 w2 + 1 or 都删 + 2
                        int temp = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
                        dp[i][j] = Math.min(temp, dp[i - 1][j - 1] + 2);
                    }
                }
            }

            return dp[word1.length()][word2.length()];
        }

```



## 编辑距离

[72]

使word1 = word2,可以删除,添加,或者替换

> 要明白`删除 = 添加,删除 word1 等于添加 word2 `
>
> dp[i]\[j] 表示 i,j 为结尾的字符串最少操作后使其相同
>
> 当 w1[i] = w2[i] 时,无需操作,dp[i]\[j] = dp[i-1]\[j-1]
>
> 否则
>
> 删除:  
>
> 删 w1 或者删 w2,删 w1 就是在以 i-1,j 结尾的基础上加一个操作
>
> 删 w2 亦然
>
> ```
> 删除 w1  ==> dp[i-1][j] + 1
> 删除 w2  ==> dp[i][j-1] + 1 
> ```
>
> 替换:
>
> 在i-1,j-1基础上操作一次即可
>
> ```
> dp[i-1][j-1] + 1
> ```
>
> 



```java
        public int minDistance(String word1, String word2) {
            int[][] dp = new int[word1.length() + 1][word2.length() + 1];
            for (int i = 0; i <= word1.length(); i++) {
                dp[i][0] = i;
            }
            for (int i = 0; i <= word2.length(); i++) {
                dp[0][i] = i;
            }

            for (int i = 1; i <= word1.length(); i++) {
                for (int j = 1; j <= word2.length(); j++) {
                    if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        // 插入
                        // 删除
                        // 给 w1 插入,相当于给 w2 做删除操作
                        // 为什么没有同时删除? 因为替换一个肯定比删除俩来的操作少
                        int delTemp = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
                        // 替换
                        int temp = dp[i - 1][j - 1] + 1;

                        // 取最小值
                        dp[i][j] = Math.min(delTemp, temp);
                    }
                }
            }
            return dp[word1.length()][word2.length()];
        }

```



## 回文子串

[647]

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。



> dp[i]\[j] 表示 i-j 是不是回文子串
>
> 如果 s[i] = s[j] 
>
> i=j 时,是回文子串
>
> j = i+1 时,是回文子串
>
> dp[i+1]\[j-1] 是回文子串是,它是回文子串



代码:

```java
    public int countSubstrings(String s) {
        boolean[][] dp = new boolean[s.length()][s.length()];
        int count = 0;
        for(int j = 0; j < s.length(); j++){
            for(int i = j; i >= 0; i--){
                if(s.charAt(i) == s.charAt(j)){
                    // 长度为 1/2 时, 不用判断其子串 -> j-i <= 1
                    // 长度大于 2 时, 要判断其子串是否为回文
                    if(j - i <= 1 || dp[i + 1][j - 1]){
                        dp[i][j] = true;
                        count++;
                    }
                }
            } 
        }
        return count;
    }
```



中心扩展:

```java
        public int countSubstrings(String s) {
            // 有 2*len - 1 个扩展点
            int len = s.length() * 2 - 1;
            int count = 0;
            // left和right指针和中心点的关系是？
            // 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），
            // 也可能往后移动一个（奇数）
            // 大致的关系出来了，可以选择带两个特殊例子进去看看是否满足。
            for (int center = 0; center < len; center++) {
                int start = center >> 1;
                int end = start + (center & 1);

                while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)){
                    count++;

                    start--;
                    end++;
                }
            }

            return count;
        }

```



## 最长回文子串

[5]

> 遍历顺序和回文子串一样,dp数组改为 i-j 回文子串长度(0代表不是回文串)
>
> 定义左边界和右边界



代码:

```java
        public String longestPalindrome(String s) {
            boolean[][] dp = new boolean[s.length()][s.length()];
            int f = 0;
            int e = 0;
            for(int j = 0; j < s.length(); j++){
                for(int i = j; i >= 0; i--){
                    if(s.charAt(i) == s.charAt(j)){
                        if((j - i) <= 1 || dp[i + 1][j - 1]){
                            dp[i][j] = true;

                            if(j - i > e - f){
                                e = j;
                                f = i;
                            }
                        }
                    }

                }
            }
            return s.substring(f, e+1);
        }

```



## 最大回文子序列

[516]

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

> 子序列不要求是连续的
>
> dp[i]\[j] 表示i-j的子序列里最大回文子序列长度
> 遍历方法和上面回文子串遍历方法一样,区别是,当 s[i] = s[j] 时说明可以在原来的基础上增加回文串了,如果 j-i >= 2, dp[i]\[j] = dp[i+1]\[j-1] + 2; 如果不等于说明不能增加,那就选一个最大的回文子序列,这里不是i+1~j-1哦,因为 j-1 可能会和 i 匹配, i+1 也可能会和 j 匹配,所以这里是
>
> max(dp[i+1]\[j], dp[i]\[j-1]);
>
> `所以和回文子串不同的就是当s[i] != s[j] 的时候`



代码:

```java
        public int longestPalindromeSubseq(String s) {
            // dp[i][j] 表示 i-j 回文子序列的最大长度
            int[][] dp = new int[s.length()][s.length()];
            int maxLen = 0;
            for (int i = s.length() - 1; i >= 0; i--) {
                dp[i][i] = 1;
                for (int j = i + 1; j < s.length(); j++) {
                    if (s.charAt(i) == s.charAt(j)) {
                        if (j - i == 1) {
                            dp[i][j] = 2;
                        } else {
                            dp[i][j] = dp[i + 1][j - 1] + 2;
                        }
                    } else {
                        dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                    }
                }
            }

            return dp[0][s.length() - 1];
        }

```



## 把数字翻译成字符串

[剑指 offer 46]

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof

> 这道题求的其实是组合方式有多少种, 如果只有一个数 a,那组合方式只有一种 1,如果在加一个数 2,组合方式就是1,2 and 12, 如果在加一个数3,那就有1,2,3 and 12,3 and 1,23
>
> 可以看到,新加一个数的时候它的组合方式就是 dp[i-1] + dp[i-2], dp[i-1] 代表当前新加的作为单独的一个数的情况,dp[i-2] 代表当前数和前一个数作为一个数的情况,但是这里要求组合的数要小于 25



代码:

```java
        public int translateNum(int num) {
            // dp[i] 表示以 i 为结尾的数字有多少种组合方式
            String str = String.valueOf(num);
            int[] dp = new int[str.length() + 1];
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= str.length(); i++) {
                if (str.charAt(i-2) != '0' && Integer.parseInt(str.substring(i - 2, i)) <= 25) {
                    dp[i] = dp[i - 1] + dp[i - 2];
                } else {
                    dp[i] = dp[i - 1];
                }
            }
            return dp[str.length()];
        }
```



## 丑数

[剑指offer 49]

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**示例:**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```



> 丑数递增的,递增的规律是 2\*x, 3\*y, 5\*z 三个数里面最小的一个,我们直接看例子
>
> 首先 1 是丑数,让 x,y,z 都等于 1
>
> 1. min(2\*x, 3\*y, 5\*z) 最小的是 2*1 = 2, 所以下一个丑数是 2
> 2. min(2\*x, 3\*y, 5\*z) 最小的是 2*1 = 2, 所以下一个丑数是 2,咦....好像不对,怎么还是 2, 哦乘过一次后 x 应该递增成下一个丑数的,不然就永远 2,2,2,2,2,2 了, 那在第一次乘 2 后 x 就应该更新成下一个丑数也就是 2
> 3. min(2\*x, 3\*y, 5\*z) 最小的是 3 * 1 = 3, 所以下一个丑数是 3, 同时 y 更新为 2
> 4. min(2\*x, 3\*y, 5\*z) 最小的是 2*2 = 4, 所以下一个丑数是 4, 同时 x 更新成下一个丑数 4
> 5. min(2\*x, 3\*y, 5\*z) 最小的是 5*1 = 5, 所以下一个丑数是 5, 同时 z 更新成下一个丑数 2
> 6. ....依次类推



代码:

```java
    public int nthUglyNumber(int n) {
        // dp[i] 第 i 个丑数
        int[] dp = new int[n + 1];
        int a = 1,b = 1,c = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            int n1 = dp[a] * 2;
            int n2 = dp[b] * 3;
            int n3 = dp[c] * 5;

            int min = Math.min(n1, Math.min(n2, n3));
            dp[i] = min;

            if(dp[i] == n1) a++;
            if(dp[i] == n2) b++;
            if(dp[i] == n3) c++;
        }

        return dp[n];
    }
```

