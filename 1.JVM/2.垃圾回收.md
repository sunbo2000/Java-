# 垃圾回收

### 1. 如何判断对象可以回收

#### 1.1 引用计数法

- 对每一个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
- 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象的引用计数器的值为0，即表示对象A不能在被使用，可进行回收。

##### 循环引用

A 引用 B,B 引用 A,但是A,B都没有在被别的对象引用, 引用计数法不能回收

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220809142732036.png" alt="image-20220809142732036" style="zoom:67%;" />

#### 1.2 可达性分析算法

延根提葡萄,提起来的保留,掉下去的回收

- Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
- 扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收

##### 哪些对象可以作为 GC Root ?

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。　
- 本地方法栈中JNI（即一般说的Native方法）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象,比如 <u>StringTable</u>
- 所有被同步锁 synchronized 持有的对象
- java 虚拟机内部引用对象
  - 基本数据类型对应的 Class 对象,一些常驻的异常对象,系统类加载器


#### 1.3 五种引用

1.强引用

![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200608150800.png)

只有 GC Root **都不引用**该对象时，才会回收**强引用**对象

- 如上图B、C对象都不引用A1对象时，A1对象才会被回收

2.软引用

SoftReference 所指向的对象，当没有强引用指向它时，会在内存中停留一段的时间，垃圾回收器会根据 JVM 内存的使用情况（内存的紧缺程度）以及 SoftReference 的 get() 方法的调用情况来决定是否对其进行回收。

- 如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收
  - 进行一次垃圾回收后发现内存仍然不足, 回收被软引用对象

```java
public class Demo1 {
    
    final int _4MB = 1024 * 1024 * 4;
    
    // list 对 byte[] 是强引用
    public void strongReferenceTest() {
        List<byte[]> list = new ArrayList<>();

        list.add(new byte[_4MB]);
    }
    
    //使用软引用对象 list 对 softReference 是强引用
    // softReference 对 byte[] 是软引用
    public void softReferenceTest() {
        List<SoftReference<byte[]>> list = new ArrayList<>();

        SoftReference<byte[]> softReference = new SoftReference<>(new byte[_4MB]);

        list.add(softReference);
    }
}
```

- 如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，**软引用本身(softReference)不会被清理**

- 如果想要**清理软引用**，需要使**用引用队列**

  ```java
   public void softReferenceTest() {
          // 引用队列
          ReferenceQueue<byte[]> queue = new ReferenceQueue<byte[]>();
       
          List<SoftReference<byte[]>> list = new ArrayList<>();
          // 关联了引用队列之后,当软引用对象被回收后,软引用本身会加入到 queue 中
          
          for...
          SoftReference<byte[]> softReference = new SoftReference<>(new byte[_4MB],queue);
          list.add(softReference);
          
       
          //移除软引用
          Reference<? extends byte[]> poll = queue.poll();
          while (poll != null) {
              list.remove(poll);
              poll = queue.poll();
          }
       
      }
  ```

  

3.弱引用

弱引用的特性和基本与软引用相似，区别就在于弱引用所指向的对象(没有强引用指向它)只要进行系统垃圾回收，不管内存使用情况如何，永远对其进行回收（get() 方法返回 null）。

- 如上图如果B对象不再引用A3对象，则A3对象会被回收

**弱引用的使用和软引用类似**，只是将 **SoftReference 换为了 WeakReference**

```java
    public void weakReferenceTest() {
        List<WeakReference<byte[]>> list = new ArrayList<>();
        WeakReference<byte[]> weakReference = new WeakReference<>(new byte[_4MB]);
        list.add(weakReference);
    }
```

- 对引用本身的回收与软引用相同

4.虚引用

**虚引用所引用对象不会被被释放直到所有指向该对象的虚引用被清除。**

如果 GC 在某个时间点确定虚引用的所指对象只有虚引用可达，届时或稍后将其加入引用队列。和软引用以及虚引用不同，在其加入引用队列时，不会自动被 GC 清除。

虚引用所引用对象不会被被释放直到所有指向该对象的虚引用被清除，所以， 虚引用通常用来跟踪对象被垃圾回收的活动。

5.终结器引用

所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了

- 如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了

#### 1.4 对象的 finalization 机制

- Java语言提供了对象终止 (finalization) 机制来允许开发人员**提供对象被销毁之前的自定义处理逻辑。**
- 当垃圾回收器发现没有引用指向一个对象，即: **垃圾回收此对象之前，总会先调用这个对象的finalize()方法。**
- finalize() 方法允许在子类中被重写，**用于在对象被回收时进行资源释放。**通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。

永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包
括下面三点:

- 在finalize() 时可能会导致对象复活。
- finalize() 方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize() 方法将没有执行机会。
- 一个糟糕的finalize ()会严重影响GC的性能。


从功能上来说，finalize() 方法与C+ +中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize ()方法在本质上不同于C++中的析构函数。

**由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。**

如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下:

- **可触及的**: 从根节点开始，可以到达这个对象。
- **可复活的**: 对象的所有引用都被释放，但是**对象有可能在finalize ()中复活。**
- **不可触及的**: 对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可 触及的对象不可能被复活，因为finalize() 只会被调用一次。

以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触
及时才可以被回收。

##### 具体过程

判定一个对象objA是否可回收，至少要经历两次标记过程:|

1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。

2. 进行筛选，判断此对象是否有必要执行finalize()方法

   - 如果对 象 objA 没有重写 finalize() 方法，或者 finalize () 方法已经被虛拟机调用过,则虚拟机视为“没有必要执行”，objA 被判定为**不可触及的**。

   - 如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。
   
   - **finalize() 方法是对象逃脱死亡的最后机会**，稍后 Gc 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，**对象再次出现没有引用存在的情况**。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize方法只会被调用一次。

### 2. 垃圾回收算法

#### 2.1 标记清除算法

![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200608150813.png)

**定义**：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间

- 这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接**覆盖**这段内存

**缺点**：**容易产生大量的内存碎片**，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢

#### 2.2 标记整理算法

![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200608150827.png)

标记-整理 会将不被 GC Root 引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整理需要消耗一定的时间，所以效率较低

> 标记整理慢的原因: 标记整理算法需要先遍历一遍对对象进行标记. 标记过后把他们从内存开始的区域按顺序一次摆好
>
> 对象的遍历过程和内存的摆放顺序不是一致的, 很可能一个对象摆放在内存的前面部分, 但是需要等到最后的时候才能遍历到这个对象, 因此, 如果提前开始整理, 会影响到这个对象.

#### 2.3 复制算法

![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200608150842.png)

将内存分为等大小的两个区域，FROM 和 TO（TO 中为空）。先将被 GC Root 引用的对象从 FROM 放入 TO 中，再回收不被 GC Root 引用的对象。然后交换 FROM 和 TO。这样也可以避免内存碎片的问题，缺点是你会占用双倍的内存空间。

### 3. 分代垃圾回收

![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200608150931.png)

#### 3.1 回收流程

新创建的对象都被放在了**新生代的伊甸园**中

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608150939.png" alt="img" style="zoom:80%;" />

当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 **Minor GC**

Minor GC 会将伊甸园存活的对象复制到 **幸存区 From**中， 并让其**寿命加1**，再**交换两个幸存区**

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608150946.png" alt="img" style="zoom:80%;" />

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608150955.png" alt="img" style="zoom:80%;" />

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220815193640248.png" alt="image-20220815193640248" style="zoom:80%;" />

再次创建对象，若新生代的伊甸园又满了，则会**再次触发 Minor GC**（会触发 **stop the world**， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，**还会回收幸存区中的垃圾**，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象**寿命加1**

如果幸存区中的对象的**寿命超过某个阈值**（最大为15，4bit），就会被**放入老年代**中

如果新生代老年代中的内存都满了，就会先触发 Minor GC，再触发 **Full GC**，扫描**新生代和老年代中**所有不再使用的对象并回收



#### 3.2 相关 VM 参数

| 含义              | 参数                                                        |
| ----------------- | ----------------------------------------------------------- |
| 堆初始大小        | -Xms                                                        |
| 堆最大大小        | -Xmx 或 -XX:MaxHeapSize=size                                |
| 新生代大小        | -Xmn 或 (-XX:NewSize= =size + -XX:MaxNewSize=size )         |
| 幸存区比例(动态)  | -XX:InitialSurvivorRatio=ratio 和-XX:+UseAdaptiveSizePolicy |
| 幸存区比例        | -XX:SurvivorRatio=ratio                                     |
| 晋升阈值          | -XX:MaxTenuring Threshold=threshold                         |
| 晋升详情          | -XX:+PrintTenuringDistribution                              |
| GC 详情           | -XX:+PrintGCDetails -verbose:gc                             |
| FullGC 前 MinorGC | -XX:+ScavengeBeforeFullGC                                   |

#### 3.3 GC 分析

##### 1. 大对象处理策略

当遇到一个**较大的对象**时，就算新生代的**伊甸园**为空，也**无法容纳该对象**时，会将该对象**直接晋升为老年代**

##### 2. 线程内存溢出

某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行

这是因为当一个线程**抛出OOM异常后**，**它所占据的内存资源会全部被释放掉**，从而不会影响其他线程的运行，**进程依然正常**

### 4. 垃圾回收器

#### 4.1 串行

- 单线程垃圾回收器

- 堆内存比价小,适合个人电脑

- 新生代使用**复制**算法,老年代使用**标记整理**算法

  <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151027-16605750723702.png" alt="img" style="zoom:80%;" />

**安全点**：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象

因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入**阻塞**状态

##### Serial 收集器 - 新生代

Serial收集器是最基本的、发展历史最悠久的收集器

**特点：**单线程、简单高效（与其他收集器的单线程相比），采用**复制算法**。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World)	

##### ParNew 收集器 - 新生代

ParNew收集器其实就是Serial收集器的多线程版本

**特点**：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在 (Stop The World) 问题

##### Serial Old 收集器 - 老年代

Serial Old 是 Serial 收集器的老年代版本

**特点**：同样是单线程收集器，采用**标记-整理算法**

#### 4.2 吞吐量优先

- 多线程

- 堆内存大,多核 cpu 支持(单核 CPU 并发运行多线程效率并不高)

- 让单位时间内 stw(stop the world，停掉其他所有工作线程) 的时间最短

- 新生代使用复制算法,老年代使用标志整理算法

- **JDK1.8默认使用**的垃圾回收器

- 并行执行垃圾回收

  <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151039-16606402629615.png" alt="img" style="zoom:80%;" />

##### Parallel Scavenge 收集器 - 新生代

与吞吐量关系密切，故也称为吞吐量优先收集器

**吞吐量**: 吞吐量就是指垃圾回收的时间占程序运行时间的占比，垃圾回收时间占比越低，那么就指吞吐量越高，这是吞吐量它的一个含义。

**特点**：属于新生代收集器也是采用**复制算法**的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与 ParNew 收集器类似）

**但是该收集器的目标是达到一个可控制的吞吐量**。还有一个值得关注的点是：**GC自适应调节策略**（与 ParNew 收集器最重要的一个区别）

**GC自适应调节策略**：Parallel Scavenge 收集器可设置-XX:+UseAdptiveSizePolicy 参数。当开关打开时**不需要**手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。

Parallel Scavenge收集器使用两个参数控制吞吐量：

- XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
- XX:GCRatio 直接设置吞吐量的大小

##### **Parallel Old 收集器 - 老年代**

是Parallel Scavenge收集器的老年代版本

**特点**：多线程，采用**标记-整理算法**（老年代没有幸存区）

#### 4.3 响应时间优先(CMS) - 老年代

- 多线程

- 堆内存大,多核 cpu 支持

- 尽可能让单次 stw(stop the world) 时间最短(尽量不影响其他线程)

- 可以和用户进程并发执行

  ![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200608151052-16606408749648.png)

##### CMS 收集器

Concurrent Mark Sweep，一种以获取**最短回收停顿时间**为目标的**老年代**收集器

**特点**：基于**标记-清除算法**实现。并发收集、低停顿，但是会产生内存碎片

**应用场景**：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务

**CMS收集器的运行过程分为下列4步：**

**初始标记**：标记GC Roots能直接到的对象。速度很快但是**仍存在Stop The World问题**

**并发标记**：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行

**重新标记**：为了**修正并发标记期间**因用户程序继续运 行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题

**并发清除**：对标记的对象进行清除回收

CMS收集器的内存回收过程是与用户线程一起**并发执行**的

#### 4.4 G1 - 兼顾新生代和老年代

##### **定义**：

Garbage First

JDK 9以后默认使用，而且替代了CMS 收集器

![img](D:\A.学习资料\A.笔记\1. JVM\assets\20200909201212.png)

##### 适用场景

- **在延迟可控的情况下获得尽可能高的吞吐量,同时注重吞吐量和低延迟（响应时间）**
- 超大堆内存（内存大的），会将堆内存划分为多个**大小相等**的区域
- 整体上是**标记-整理**算法，两个区域之间是**复制**算法

**相关参数**：JDK8 并不是默认开启的，所需要参数开启

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151100.png" alt="img" style="zoom:80%;" />

##### G1垃圾回收阶段

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151109.png" alt="img" style="zoom: 50%;" />

新生代伊甸园垃圾回收 —–> 内存不足，新生代回收+并发标记—–>回收新生代伊甸园、幸存区、老年代内存——>新生代伊甸园垃圾回收(重新开始)

##### Young Collection

**分区算法region**

分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间

E：伊甸园 S：幸存区 O：老年代

- 会STW

  <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151119-16606430228385.png" alt="img" style="zoom:50%;" />

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151129.png" alt="img" style="zoom:50%;" />

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151140.png" alt="img" style="zoom:50%;" />

##### Young Collection + CM

CM：并发标记

- 在 Young GC 时会**对 GC Root 进行初始标记**

- 在老年代**占用堆内存的比例**达到阈值时，堆进行并发标记（不会STW），阈值可以根据用户来进行设定

  <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151150.png" alt="img" style="zoom:50%;" />

##### Mixed Collection

会对E S O 进行**全面的回收**

- 最终标记
- **拷贝**存活

-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间

**问**：为什么有的老年代被拷贝了，有的没拷贝？

因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会**回收最有价值的老年代**（回收后，能够得到更多内存 

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151201.png" alt="img" style="zoom:50%;" />

##### Full GC

G1在老年代内存不足时（老年代所占内存超过阈值）

- 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
- 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

#### 4.5 Young Collection 跨代引用

堆空间通常被划分为新生代和老年代，所谓跨代引用，一般是指老年代对象引用了新生代的对象。如下图的X和Y引用：

![img](D:\A.学习资料\A.笔记\1. JVM\assets\122d125279e236d2229a4a80b000bc1d.png)

我们知道新生代的垃圾收集通常很频繁（朝生夕死），如果老年代对象引用了新生代的对象，那么在回收新生代（Young GC）的时候，需要跟踪从老年代到新生代的所有引用。

**记忆集**

跨代引用主要存在于Young GC的过程中，除了常见的GC Roots之外，**如果老年代有对象引用了的新生代对象，那么老年代的对象也属于GC Roots（如上图中的老年代对象B和C）对象**，但是如果每次进行Young GC我们都需要扫描一次老年代的话，那我们进行垃圾回收的代价实在是太大了，**因此收集器在新生代上建立一个全局的称为记忆集的数据结构来记录这种引用关系。**

Rset(Remember Set)，简单来说就是**一种抽象数据结构用来存老年代对象对新生代的引用（即引用X和Y）。**

![img](D:\A.学习资料\A.笔记\1. JVM\assets\7f61719ac2028f0533cbc73e15af5c44.png)

**卡表**

在 CMS 中,卡表可以看做是对记忆集的实现,如下图

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\auto-orient,1.png" alt="auto-orient,1" style="zoom:80%;" />



上述的卡表机制基本上适用于CMS垃圾回收器，因为CMS垃圾回收器只需要在young gc时维护老年代对新生代的引用即可，但是G1垃圾回收器不一样，因为G1垃圾回收器是基于分区模型的，所以每一个Region需要知道有哪些region的引用指向了它，并且这些region是不是本次垃圾回收区域的一部分。因此G1垃圾回收器不能简单的只维护一个卡表(卡表只能简单的知道某块内存区域有没有引用收集区域的对象，但是不能知道到底是谁引用了自己)，所以在G1垃圾回收器的记忆集的实现实际上是基于哈希表的，key代表的是其他region的起始地址，value是一集合，里面存放了对应区域的卡表的索引，因此G1的region能够通过记忆集知道，当前是哪个region有引用指向了它，并且能知道是哪块区域存在指针指向。

每个region都维护一个记忆集，内存占用量肯定很大，这也就是为什么G1垃圾回收器比传统的其他垃圾回收器要有更高的内存占用。据统计G1至少要耗费大约10%-20%的Java收集器的工作。



由于在Young GC的过程中，需要扫描整个老年代，效率非常低，所以 JVM 设计了卡表，如果一个老年代的卡表中有对象指向新生代， 就将它设为 Dirty（标志位 1，反之设为0），下次扫描时，只需要扫描卡表上是 Dirty 的内存区域即可。 而卡表和记忆集的关系可以理解为一个HashMap，类似于下图的样子。

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\480cc49ae398a41d453aa5359abcf651.png" alt="img" style="zoom:80%;" />

这个时候根据记忆集合卡表的记录，我可以直接确定扫描记忆集确定Card[1]的位置，而不需要扫描整个老年代。

- 在引用变更时通过post-write barried + dirty card queue
- concurrent refinement threads 更新 Remembered Set
- <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151222.png" alt="img" style="zoom:50%;" />

#### 4.6 重标记

重新标记阶段

在垃圾回收时，收集器处理对象的过程中

黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151229.png" alt="img" style="zoom: 50%;" />

但是在**并发标记过程中**，有可能出现 C 已经被处理完了是白色,但是用户线程又改变了 C 的引用,C 又被 A 引用了. 这时就会用到remark

过程如下

- 之前 C 未被引用，这时 A 引用了 C，就会给 C 加一个写屏障，写屏障的指令会被执行，将 C 放入一个队列当中，并将 C 变为 处理中 状态

- 在**并发标记**阶段结束以后，重新标记阶段会 STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它

  <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151239.png" alt="img" style="zoom:50%;" />



#### 4.7 G1优化

##### JDK 8u20 字符串去重

过程

- 将所有新分配的字符串（底层是char[]）放入一个队列
- 当新生代回收时，G1并发检查是否有重复的字符串
- 如果字符串的值一样，就让他们**引用同一个字符数组char[]**
- 注意，其与String.intern的区别
  - intern关注的是字符串对象
  - 字符串去重关注的是char[], 字符串对象不同但是两个字符串对象内的属性引用的字符数组相同
  - 在JVM内部，使用了不同的字符串标

优点与缺点

- 节省了大量内存
- 新生代回收时间略微增加，导致略微多占用CPU

##### JDK 8u40 并发标记类卸载

在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类,指用户自定义的类加载器,系统的类加载器不会不在使用

##### JDK 8u60 回收巨型对象

- 巨型对象区

- 一个对象大于 region 的一半时，就称为巨型对象

- G1 不会对巨型对象进行拷贝

- 回收时被优先考虑

- G1 会跟踪老年代所有 incoming 引用，如果老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉

  <img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151249.png" alt="img" style="zoom:50%;" />

##### JDK 9并发标记起始时间的调整

并发标记必须在堆空间占满前完成，否则退化为FulIGC

- JDK9之前需要使用-XX: InitiatingHeapOccupancyPercent
- JDK 9可以动态调整
- -XX:InitiatingHeapOccupancyPercent用来设置初始值
- 进行数据采样并动态调整
- 总会添加一个安全的空档空间



#### 总结

![image-20220817152849375](D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817152849375.png)