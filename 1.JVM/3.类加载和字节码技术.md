# 类加载和字节码技术

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\20200608151300.png" alt="img" style="zoom: 80%;" />

## 1.字节码指令

### 1. 类文件结构

首先获得.class字节码文件

方法(编译一下)：

- 在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java
- java终端中，执行javac X:...\XXX.java

如下:

```
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 
0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 
0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 
0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 
0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 
0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 
0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 
0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 
0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 
0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 
0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 
0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 
0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 
0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 
0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64
0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 
0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 
0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 
0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 
0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 
0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 
0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 
0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 
0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 
0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 
0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 
0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 
0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 
0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 
0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 
0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 
0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 
0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 
0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 
0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 
0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 
0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 
0001120 00 00 02 00 14
```

根据 JVM 规范，**类文件结构**如下

```java
u4 			 magic
u2             minor_version;    
u2             major_version;    
u2             constant_pool_count;    
cp_info        constant_pool[constant_pool_count-1];    
u2             access_flags;    
u2             this_class;    
u2             super_class;   
u2             interfaces_count;    
u2             interfaces[interfaces_count];   
u2             fields_count;    
field_info     fields[fields_count];   
u2             methods_count;    
method_info    methods[methods_count];    
u2             attributes_count;    
attribute_info attributes[attributes_count];
```

#### 魔数

u4 magic

对应字节码文件的0~3个字节,它表示是否是[class]类型的文件

0000000 **ca fe ba be** 00 00 00 34 00 23 0a 00 06 00 15 09

#### 版本

u2 minor_version;

u2 major_version;

0000000 ca fe ba be **00 00 00 34** 00 23 0a 00 06 00 15 09

34H = 52，代表JDK8

#### 常量池

##### 常量类型

| Constant Type               | Value |
| --------------------------- | ----- |
| CONSTANT_Class              | 7     |
| CONSTANT_Fieldref           | 9     |
| CONSTANT_Methodref          | 10    |
| CONSTANT_InterfaceMethodref | 11    |
| CONSTANT_String             | 8     |
| CONSTANT_Integer            | 3     |
| CONSTANT_Float              | 4     |
| CONSTANT_Long               | 5     |
| CONSTANT_Double             | 6     |
| CONSTANT_NameAndType        | 12    |
| CONSTANT_Utf8               | 1     |
| CONSTANT_MethodHandle       | 15    |
| CONSTANT_MethodType         | 16    |
| CONSTANT_InvokeDynamic      | 18    |

### 2. 字节码指令

#### javap工具

Oracle 提供了 **javap** 工具来反编译 class 文件

javap -v Main.class

```json
PS D:\A.Code\A.project\jvmtest\target\classes\org\snbo\complier> javap -v TestMain.class 
Classfile /D:/A.Code/A.project/jvmtest/target/classes/org/snbo/complier/TestMain.class
  Last modified 2022-8-17; size 563 bytes
  MD5 checksum afd1b9bbe015ddebd5153f1bf741dd0c
  Compiled from "TestMain.java"
public class org.snbo.complier.TestMain
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#20         // java/lang/Object."<init>":()V  
                                          # 方法引用: Object类的init方法, (): 无参 V: 无返回值
   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream; 
                                          # 变量引用: System类里的out变量,变量类型是PrintStream
   #3 = String             #23            // Hello World
   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V 
                                          # 方法引用: PrintStream类的println方法,String类型的参数,空返回值
   #5 = Class              #26            // org/snbo/complier/TestMain
   #6 = Class              #27            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lorg/snbo/complier/TestMain;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
  #16 = Utf8               args
  #17 = Utf8               [Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               TestMain.java
  #20 = NameAndType        #7:#8          // "<init>":()V
  #21 = Class              #28            // java/lang/System
  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
  #23 = Utf8               Hello World
  #24 = Class              #31            // java/io/PrintStream
  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
  #26 = Utf8               org/snbo/complier/TestMain
  #27 = Utf8               java/lang/Object
  #28 = Utf8               java/lang/System
  #29 = Utf8               out
  #30 = Utf8               Ljava/io/PrintStream;
  #31 = Utf8               java/io/PrintStream
  #32 = Utf8               println
  #33 = Utf8               (Ljava/lang/String;)V
{
  public org.snbo.complier.TestMain();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         # 将局部变量的第 0 项加入到操作数栈
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         # 执行方法Object.<init>: Object的空参构造方法
         4: return
         # 返回值为空
      LineNumberTable:
        line 7: 0 // 源代码的第7行对应字节码的第0行
      LocalVariableTable:
      # 本地变量表
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lorg/snbo/complier/TestMain;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
     # 栈深度  局部变量个数 参数个数 
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         # 取静态变量
         3: ldc           #3                  // String hello world
         # 加载常量池中的 #3 常量
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         # 执行方法PrintStream.println: 参数为String,返回值为空
         8: return
      LineNumberTable:
        line 9: 0
        line 10: 8
      LocalVariableTable:
      Start  Length  Slot  Name   Signature
          0       9     0  args   [Ljava/lang/String;
}
SourceFile: "TestMain.java"

```

### 3. 方法执行流程

1) 原始 java 代码

```java
package org.snbo;

public class MainTest {
    public static void main(String[] args) {
        int a = 10;
        int b = Short.MAX_VALUE + 1;
        int c = a + b;
        System.out.println(c);
    }
}
```

2. 编译后的字节码文件

```java
Classfile /D:/A.Code/A.project/jvmtest/target/classes/org/snbo/MainTest.class
  Last modified 2022-8-17; size 604 bytes
  MD5 checksum ddcceb7901a0d767371431cfbf2d015a
  Compiled from "MainTest.java"
public class org.snbo.MainTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #7.#25         // java/lang/Object."<init>":()V
   #2 = Class              #26            // java/lang/Short
   #3 = Integer            32768
   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V
   #6 = Class              #31            // org/snbo/MainTest
   #7 = Class              #32            // java/lang/Object
   #8 = Utf8               <init>
   #9 = Utf8               ()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               LocalVariableTable
  #13 = Utf8               this
  #14 = Utf8               Lorg/snbo/MainTest;
  #15 = Utf8               main
  #16 = Utf8               ([Ljava/lang/String;)V
  #17 = Utf8               args
  #18 = Utf8               [Ljava/lang/String;
  #19 = Utf8               a
  #20 = Utf8               I
  #21 = Utf8               b
  #22 = Utf8               c
  #23 = Utf8               SourceFile
  #24 = Utf8               MainTest.java
  #25 = NameAndType        #8:#9          // "<init>":()V
  #26 = Utf8               java/lang/Short
  #27 = Class              #33            // java/lang/System
  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;
  #29 = Class              #36            // java/io/PrintStream
  #30 = NameAndType        #37:#38        // println:(I)V
  #31 = Utf8               org/snbo/MainTest
  #32 = Utf8               java/lang/Object
  #33 = Utf8               java/lang/System
  #34 = Utf8               out
  #35 = Utf8               Ljava/io/PrintStream;
  #36 = Utf8               java/io/PrintStream
  #37 = Utf8               println
  #38 = Utf8               (I)V
{
  public org.snbo.MainTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lorg/snbo/MainTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: ldc           #3                  // int 32768
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
            3      15     1     a   I
            6      12     2     b   I
           10       8     3     c   I
}
SourceFile: "MainTest.java"

```

3. **常量池载入运行时常量池**

   <img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817203957639.png" alt="image-20220817203957639" style="zoom:80%;" />

- 整数值小于 Short.MAX_VALUE 的值跟着方法的字节码指令存储在一起,数值大于 MAX_VALUE 的会存储在常量池

4. **方法的字节码载入方法区**

   <img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817203936560.png" alt="image-20220817203936560" style="zoom:80%;" />

5. **main 线程开始运行，分配栈帧内存**

   （stack=2，locals=4）: 深度是2的操作数栈,用来**存储数据和字节码指令**, 4个槽位的**局部变量表**

     stack = 2, 操作数栈有两个空间,一个空间 4 个字节

   <img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817204536564.png" alt="image-20220817204536564" style="zoom:80%;" />

6. **执行引擎开始执行字节码**

   **执行引擎开始一步步从方法区读取 main 方法中的字节码指令,开始运行**

**bipush 10**

- 将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有
  - sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）
  - ldc 接收8位参数，指向常量池中的int、float或String，将常量池中指定内容压入栈（根据索引搜索）
  - ldc_w 接收16位参数，索引常量池的范围更大
  - ldc2_w 接收两个 8 位数，索引范围更大,用于压如入 long 类型和 double 类型的数据(分两次压入)
  - 这里小的数字都是和字节码指令存在一起，**超过 short 范围的数字存入了常量池**

**istore 1**

将操作数从栈顶弹出,放入局部变量表的 slot 1 中

对应代码: int a = 10;

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817211807252.png" alt="image-20220817211807252" style="zoom: 67%;" />



**Idc #3**

- 从常量池加载 #3 数据到操作数栈
- 注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算
  好的

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817213525991.png" alt="image-20220817213525991" style="zoom:80%;" />



**istore_2**

从栈顶弹出数据放入局部变量表的 slot 2 中

对应代码: int b = Short.MAX_VALUE + 1;

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817213905431.png" alt="image-20220817213905431" style="zoom:80%;" />



**iload_1**

读取局部变量表中 slot 1 操作数的值,入栈



**iload_2**

读取局部变量表中 slot_2 操组数的值,入栈



**iadd**

将栈顶的两个操作数出栈相加,再结果入栈

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817214810370.png" alt="image-20220817214810370" style="zoom:67%;" />

**istore_3**

将栈顶操作数出栈放入局部变量表的 slot 3 中



getstatic #4

通过常量池中的变量引用信息,获取到堆中的对象的引用,将该引用入栈

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817215952556.png" alt="image-20220817215952556" style="zoom:67%;" />



<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817220014975.png" alt="image-20220817220014975" style="zoom:67%;" />



**iload_3**

读取局部变量表中 slot 3 操作数的值,入栈



**invokevirtual #5**

- 找到常量池 #5 项
- 定位到方法区 java/io/PrintStream.println:(I)V 方法
- 生成新的栈帧（分配 locals、stack等）
- 传递参数，执行新栈帧中的字节码

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817220754378.png" alt="image-20220817220754378" style="zoom: 80%;" />

- 执行完毕，弹出栈帧
- 清除 main 操作数栈内容

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220817220925718.png" alt="image-20220817220925718" style="zoom: 80%;" />

**return**

- 完成 main 方法调用，弹出 main 栈帧
- 程序结束

### 4. 通过字节码指令分析问题

```java
public class MainTest {
    public static void main(String[] args) {
        int a = 10;
        int b = a++ + ++a + a--;
        System.out.println(a);
        System.out.println(b);
    }
}
```

```js
...
Constant pool:
   #1 = Methodref          #5.#22         // java/lang/Object."<init>":()V
   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = Methodref          #25.#26        // java/io/PrintStream.println:(I)V
   #4 = Class              #27            // org/snbo/MainTest
   #5 = Class              #28            // java/lang/Object
   #6 = Utf8               <init>
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               Lorg/snbo/MainTest;
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               args
  #16 = Utf8               [Ljava/lang/String;
  #17 = Utf8               a
  #18 = Utf8               I
  #19 = Utf8               b
  #20 = Utf8               SourceFile
  #21 = Utf8               MainTest.java
  #22 = NameAndType        #6:#7          // "<init>":()V
  #23 = Class              #29            // java/lang/System
  #24 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;
  #25 = Class              #32            // java/io/PrintStream
  #26 = NameAndType        #33:#34        // println:(I)V
  #27 = Utf8               org/snbo/MainTest
  #28 = Utf8               java/lang/Object
  #29 = Utf8               java/lang/System
  #30 = Utf8               out
  #31 = Utf8               Ljava/io/PrintStream;
  #32 = Utf8               java/io/PrintStream
  #33 = Utf8               println
  #34 = Utf8               (I)V
{
  public org.snbo.MainTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 5: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lorg/snbo/MainTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: bipush        10        # 将 10 入栈
         2: istore_1                # 栈顶操作数 10 出栈,放入局部变量表 slot 1 中  -->  int a = 10;
         3: iload_1                 # 读取局部变量表 slot 1 的值,入栈  此时操作数栈: [10]
         4: iinc          1, 1      # 直接更新局部变量区里的变量,进行加 1 操作,不需要进行入栈操作
         7: iinc          1, 1      # 同上
        10: iload_1                 # 读取局部变量表 slot 1 的值,入栈, 此时操作数栈: [12,10]
        11: iadd                    # 栈顶操作数出栈相加,结果入栈      此时操作数栈: [22]
        12: iload_1                 # 读取局部变量表 slot 1 的值,入栈  此时操作数栈: [12,22]
        13: iinc          1, -1     # 直接更新局部变量区里的变量,进行减 1 操作 
        16: iadd                    # 栈顶栈顶操作数出栈相加,结果入栈      此时操作数栈: [34]
        17: istore_2                # 栈顶操作数出栈放入局部变量表的 slot 2 中
        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        21: iload_1
        line 9: 18
        line 10: 25
        line 11: 32
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      33     0  args   [Ljava/lang/String;
            3      30     1     a   I
           18      15     2     b   I
}

```

分析：

- 注意 **iinc** 指令是**直接在局部变量 slot 上进行运算**
- a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc

### 5. 条件判断指令

| 指令 | 助记符    | 含义             |
| ---- | --------- | ---------------- |
| 0x99 | ifeq      | 判断是否 == 0    |
| 0x9a | ifne      | 判断是否 != 0    |
| 0x9b | iflt      | 判断是否 < 0     |
| 0x9e | ifle      | 判断是否 <= 0    |
| 0x9d | ifgt      | 判断是否 > 0     |
| 0x9c | ifge      | 判断是否 >= 0    |
| 0x9f | if_icmpeq | 两个int是否 ==   |
| 0xa0 | if_icmpne | 两个int是否 !=   |
| 0xa1 | if_icmplt | 两个int是否 <    |
| 0xa4 | if_icmple | 两个int是否 <=   |
| 0xa3 | if_icmpgt | 两个int是否 >    |
| 0xa2 | if_icmpge | 两个int是否 >=   |
| 0xa5 | if_acmpeq | 两个引用是否 ==  |
| 0xa6 | if_acmpne | 两个引用是否 !=  |
| 0xc6 | ifnull    | 判断是否 == null |
| 0xc7 | ifnonnull | 判断是否 != null |

几点说明：

- byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节

例:

```java
public static void main(String[] args) {
        int a = 0;
        if (a == 0) {
            a = 10;
        } else {
            a = 20;
        }
    }
```

字节码:

- 当int取值**-1~5**时，JVM采用**iconst**指令将常量压入栈中

```js
         0: iconst_0          # 将 0 入栈
         1: istore_1          # 栈顶出栈,放入局部变量表的 slot 1 
         2: iload_1           # 读取局部变量表的 slot 1 的值,将值入栈
         3: ifne          12  # 判断操作数栈顶的元素是不是不等于0,如果不等于,跳到 12 行
         6: bipush        10  # 将 10 入栈(10 < Short.MAX_VALUE 存储在方法的字节码指令里) 
         8: istore_1          # 栈顶操作数出栈,放入局部变量表 slot 1 中
         9: goto          15  # 跳到 15 行
        12: bipush        20
        14: istore_1
        15: return

```

例2:

```java
    public static void main(String[] args) {
        int a = 3;
        if (a == 3) {
            a = 10;
        } else {
            a = 20;
        }
    }
```

```js
         0: iconst_3          # 将 3 入栈
         1: istore_1          # 出栈放入 slot 1
         2: iload_1           # 取 slot 1 的值入栈
         3: iconst_3          # 将 3 入栈
         4: if_icmpne     13  # 比较栈顶两个 int 数据是否不相等
         7: bipush        10
         9: istore_1
        10: goto          16
        13: bipush        20
        15: istore_1
        16: return

```

### 6.循环控制指令

```java
    public static void main(String[] args) {
        int a = 0;
        while (a < 5) {
            a++;
        }
    }
```

```js
         0: iconst_0
         1: istore_1
         2: iload_1
         3: iconst_5
         4: if_icmpge     13
         7: iinc          1, 1
        10: goto          2

```

### 7. x = x++

```java
    public static void main(String[] args) {
        int x = 0;
        x = x++; // x 的值先放入操作数栈,然后对 slot 1 加 1, 最后又将栈顶出栈放入 slot 1 ,所以值没有变
                 // 如果是 ++x , 会先对 slot 1 加 1,在入栈,出栈
        System.out.println(x);
    }
```

```js
         0: iconst_0                         # 0 入栈                 [0]
         1: istore_1                         # 0 放入 slot 1          [ ]
         2: iload_1                          # 取 slot 1 值入栈       [0]
         3: iinc          1, 1               # slot 1 自增 1  此时 slot 1 为 1
         6: istore_1                         # 出栈放入 slot 1 此时 slot 1 为 0
         7: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        10: iload_1
        11: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        line 9: 14

```

### 8. 构造方法

#### 8.1 \<cinit\>()v

- 编译器会按**从上至下的顺序**，收集所有 static **静态代码块**和**静态成员赋值**的代码，合并为一个特殊的方
  法 \<cinit\>()V 
- \<cinit\>()V 方法会在类加载的初始化阶段被调用

```java
public class Demo1 {
    static int i = 10;
    
    static {
        i = 20;
    }
    
    static {
        i = 30;
    }
}

```



```js
	   0: bipush 10
	   2: putstatic #2   // Field i:I
	   5: bipush 20
	   7: putstatic #2   // Field i:I
	   10: bipush 30
	   12: putstatic #2  // Field i:I
	   15: return
```

#### 8.2 \<init\>()v

- 编译器会按从上至下的顺序，收集所有 **{} 代码块**和**成员变量赋值**的代码，形成新的构造方法，但原始构造方法内的代码总是在最后

```java
public class Demo1 {

    private String a = "s1";

    {
        b = 20; // 类的成员变量信息会加载到方法区中,加载后有成员变量 b,所以运行时不会出错,此处也不会报错
    }

    private int b = 10;

    {
        a = "s2";
    }
    
    public Demo1(String a, int b) {
        this.a = a;
        this.b = b;
    }
}

```

字节码文件:

```js
Code:
stack=2, locals=3, args_size=3
	0: aload_0                            # slot 0 入栈
	1: invokespecial #1 // super.<init>()V # 执行父类构造方法
	4: aload_0                            # slot 0 入栈
	5: ldc #2 // <- "s1"                    # slot "s1" 入栈 (ldc 将常量池中的指定内容压栈)
	7: putfield #3 // -> this.a             # 栈顶操作数出栈,并将值赋给对象的成员变量 #3
	10: aload_0                           # 将 slot 0 入栈
	11: bipush 20 // <- 20                  # 将操作数 20 入栈(数值较小,和方法的字节码指令存放在一起)
	13: putfield #4 // -> this.b            # 栈顶操作数出栈,并将值赋给对象的成员变量 #4
	16: aload_0                           # 将 slot 0 入栈
	17: bipush 10 // <- 10                  # 10 入栈
	19: putfield #4 // -> this.b            # 栈顶操作数出栈,并将值赋给对象的成员变量 #4
	22: aload_0
	23: ldc #5 // <- "s2"
	25: putfield #3 // -> this.a
	28: aload_0 // ------------------------------
	29: aload_1 // <- slot 1(a) "s3" |
	30: putfield #3 // -> this.a |
	33: aload_0 |
	34: iload_2 // <- slot 2(b) 30 |
	35: putfield #4 // -> this.b --------------------
	38: return
```

### 9. 方法调用

```java
public class Demo3_9 {
   public Demo3_9() { 
   }
   private void test1() {
   }
   private final void test2() { 
   }
   public void test3() {
   }
   public static void test4() { 
   }
    
   public static void main(String[] args) {
       Demo3_9 d = new Demo3_9();
        d.test1();
        d.test2();
        d.test3();
        d.test4();
        Demo3_9.test4();
   }
}
```

字节码:

```js
0: new #2 // class cn/itcast/jvm/t3/bytecode/Demo3_9
3: dup
4: invokespecial #3 // Method "<init>":()V
7: astore_1
8: aload_1
9: invokespecial #4 // Method test1:()V
12: aload_1
13: invokespecial #5 // Method test2:()V
16: aload_1
17: invokevirtual #6 // Method test3:()V
20: aload_1
21: pop
22: invokestatic #7 // Method test4:()V
25: invokestatic #7 // Method test4:()V
28: return
```



- new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈
- dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 "\<init\>":()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量表 slot 1 中
- 最终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定
- 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态
- 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】
- 比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了😂
- 还有一个执行 invokespecial 的情况是通过 super 调用父类方法

### 10. 多态原理

当执行 invokevirtual 指令时，

1. 先通过栈帧中的对象引用找到对象
2. 分析对象头，找到对象的实际 Class
3. Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了
4. 查表得到方法的具体地址
5. 执行方法的字节码

### 11. 异常处理

```java
public class Demo3_11_1 {
     public static void main(String[] args) {
         int i = 0;
         try {
             i = 10;
         } catch (Exception e) {
             i = 20;
         }
     }
}
```

```js
public static void main(java.lang.String[]);
descriptor: ([Ljava/lang/String;)V
flags: ACC_PUBLIC, ACC_STATIC
	Code:
	stack=1, locals=3, args_size=1
		0: iconst_0
		1: istore_1
		2: bipush 10
		4: istore_1
		5: goto 12
		8: astore_2
		9: bipush 20
		11: istore_1
		12: return
Exception table:
	from to target type
	   2  5     8   Class java/lang/Exception
LineNumberTable: ...
	LocalVariableTable:
		Start Length Slot Name Signature
		    9     3     2 e      Ljava/lang/Exception;
		    0     13    0 args   [Ljava/lang/String;
		    2     11    1 i      I
StackMapTable: ...
MethodParameters: ...
}
```

- 可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号
- 8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置

- 因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置会被共用

#### finally

```java
public class Demo3_11_4 {
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        } finally {
            i = 30;
        }
    }
}
```

字节码:

```js
public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
        stack=1, locals=4, args_size=1
        0: iconst_0
        1: istore_1 		      // 0 -> i
        2: bipush 		10        // try   --------------------------------------
        4: istore_1  		      // 10 -> i                                     |
        5: bipush 		30 		  // finally                                     |
        7: istore_1 		      // 30 -> i                                     |
        8: goto 		27 		 // return -----------------------------------
                      
        11: astore_2 			 // catch Exceptin -> e ----------------------
        12: bipush 		20		 // |
        14: istore_1 		     // 20 -> i |
                      
        15: bipush 		30       // finally |
        17: istore_1 		     // 30 -> i |
        18: goto 		27       // return -----------------------------------
                      
        21: astore_3		     // catch any -> slot 3 ----------------------
        22: bipush 		30       // finally |
        24: istore_1 		     // 30 -> i |
        25: aload_3 		     // <- slot 3 |
        26: athrow 		         // throw ------------------------------------
        27: return
        Exception table:
        from to target type
           2  5     11   Class java/lang/Exception
           2  5     21   any		                  // 剩余的异常类型，比如 Error
           11 15    21   any 		              // 剩余的异常类型，比如 Error
        LineNumberTable: ...
        LocalVariableTable:
        Start Length Slot Name Signature
        12 3 2 e Ljava/lang/Exception;
        0 28 0 args [Ljava/lang/String;
        2 26 1 i I
        StackMapTable: ...
        MethodParameters: ...
```

- 可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程





#### finally 对返回值影响

执行如下代码时,

```java
        // 返回 2,执行 finally 代码后 2 直接被返回
        try {
            return 1;
        } finally {
            return 2;
        }

        // 返回 1 ,执行 finally 代码之前, 因为 try 里面是返回语句,遇到返回语句并且还有 finally 未执行, 返回值          1 被暂存到局部变量表中,待执行完 finally 中的代码后, 会从局部变量表中读取暂存的数,并返回
        try {
            date = 1;
            return date;
        } finally {
            date = 2;
        }

```

### 12. synchronized

```java
 public class Demo3_13 {
        public static void main(String[] args) {
            Object lock = new Object();
            synchronized (lock) {
                System.out.println("ok");
            }
       }
 }
```

字节码:

```js
public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
        stack=2, locals=4, args_size=1
        0: new #2             	// new Object
        3: dup
        4: invokespecial #1   	// invokespecial <init>:()V
        7: astore_1           	// lock引用 -> lock
        8: aload_1 			 	// <- lock （synchronized开始）
        9: dup                   // 复制一份引用
        10: astore_2 		 	// lock引用 -> slot 2
        11: monitorenter 	 	// monitorenter(lock引用)
        12: getstatic #3 	 	// <- System.out
        15: ldc #4 				// <- "ok"
        17: invokevirtual #5 	// invokevirtual println:(Ljava/lang/String;)V
        20: aload_2 			// <- slot 2(lock引用)
        21: monitorexit 		// monitorexit(lock引用)
        22: goto 30
        25: astore_3 			// any -> slot 3
        26: aload_2 			// <- slot 2(lock引用)
        27: monitorexit 		// monitorexit(lock引用)
        28: aload_3
        29: athrow
        30: return
        Exception table:
           from to target type
             12  22   25   any // 发生异常跳到 25 行 -> 解锁
             25  28   25   any // 解锁过程中出现异常重新到 25 行,重新解锁
        LineNumberTable: ...
        LocalVariableTable:
        Start Length Slot Name Signature
        0 31 0 args [Ljava/lang/String;
        8 23 1 lock Ljava/lang/Object;
        StackMapTable: ...
        MethodParameters: ...
```

- 注: 方法级别的 synchronized 不会在字节码指令中有所体现



## 2.编译期处理-语法糖

**编译期对字节码的优化和处理称之为语法糖** 

- 所谓的 语法糖，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）

- 注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。

### 2.1 默认构造器

```java
public class Demo{

}
```

idea 转换字节码:

```java
public class Demo {
    // 这个无参构造是编译器帮助我们加上的
    public Demo() {
        super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."<init>":()V
    }
}
```

### 2.2 自动拆装箱

这个特性是 JDK 5 开始加入的， 代码片段1 ：

```java
    public class Candy2 {
        public static void main(String[] args) {
            Integer x = Integer.valueOf(1);
            int y = x.intValue();
        }
    }
```

这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 :

```java
    public class Candy2 {
        public static void main(String[] args) {
            Integer x = Integer.valueOf(1);
            int y = x.intValue();
        }
    }
```

显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是
包装类型），因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。**即 代码片段1 都会在编**
**译阶段被转换为 代码片段2**

### 2.3 泛型擦除

泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息
在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：

```java
    public class Candy3 {
        public static void main(String[] args) {
            List<Integer> list = new ArrayList<>();
            list.add(10); // 实际调用的是 List.add(Object e)
            Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);
        }
    }
```

所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：

```java
// 需要将 Object 转为 Integer
Integer x = (Integer)list.get(0);
```

如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：

```java
// 需要将 Object 转为 Integer, 并执行拆箱操作
int x = ((Integer)list.get(0)).intValue();
```

擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息

```js
public cn.itcast.jvm.t3.candy.Candy3();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
        stack=1, locals=1, args_size=1
        0: aload_0
        1: invokespecial #1 // Method java/lang/Object."<init>":()V
        4: return
        LineNumberTable:
        line 6: 0
        LocalVariableTable:
        Start Length Slot Name Signature
        0 5 0 this Lcn/itcast/jvm/t3/candy/Candy3;
public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
        stack=2, locals=3, args_size=1
        0: new #2 // class java/util/ArrayList
        3: dup
        4: invokespecial #3 // Method java/util/ArrayList."<init>":()V
        7: astore_1
        8: aload_1
        9: bipush 10
        11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
        19: pop
        20: aload_1
        21: iconst_0
        22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
        27: checkcast #7 // class java/lang/Integer 进行强制类型转换操作
        30: astore_2
        31: return

        LineNumberTable:
        line 8: 0
        line 9: 8
        line 10: 20
        line 11: 31
        LocalVariableTable: //局部变量类型表,包含了方法的泛型信息
        Start Length Slot Name Signature
            8     24    1 list    Ljava/util/List<Ljava/lang/Integer;>;
```

虽然保留了泛型信息,但是局部变量的泛型信息是无法通过反射获得的,使用反射，仍然能够获得这些信息(方法参数和返回值的泛型信息)：

```java
public Set<Integer> test(List<String> list, Map<Integer, Object> map) {
}
```

```java
   public static void main(String[] args) {
        Method test = Candy3.class.getMethod("test", List.class, Map.class);
        Type[] types = test.getGenericParameterTypes();
        for (Type type : types) {
            // 判断是不是泛型参数
            if (type instanceof ParameterizedType) {
                // 转换为泛型类型类
                ParameterizedType parameterizedType = (ParameterizedType) type;
                System.out.println("原始类型 - " + parameterizedType.getRawType());
                //获取泛型对象的泛型
                Type[] arguments = parameterizedType.getActualTypeArguments();
                for (int i = 0; i < arguments.length; i++) {
                    System.out.printf("泛型参数[%d] - %s\n", i, arguments[i]);
                }
            }
        }
    }
```

总结: 泛型擦除即当编译为字节码信息后泛型被消除,所有类型都**当做 Object 类处理**, 有取值操作时,编译器编译时会加上强制转换操作,但在泛型擦除时**并不会将所有的泛型类型都擦除掉**,它只会**擦除运行时的泛型类型**，编译时类中定义的泛型类型是不会被擦除的，对应的泛型类型会被保存在Signature中(但局部变量的泛型信息不能通过反射获得)。

### 2.4 可变参数

可变参数也是 JDK 5 开始加入的新特性：
例如：

```java
    public class Candy4 {
        public static void foo(String... args) {
            String[] array = args; // 直接赋值
            System.out.println(array);
        }

        public static void main(String[] args) {
            foo("hello", "world");
        }
    }
```

可变参数 String... args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。
同样 java 编译器会在编译期间将上述代码变换为：

```java
    public class Candy4 {
        public static void foo(String[] args) {
            String[] array = args; // 直接赋值
            System.out.println(array);
        }
        public static void main(String[] args) {
            foo(new String[]{"hello", "world"});
        }
    }
```

注 : 如果调用了 foo() 则等价代码为 foo(new String[]{}) ，创建了一个空的数组，而不会传递
null 进去

### 2.5 增强 for 循环

- 数组底层是普通for循环；集合底层for增强是迭代器

### 2.6 switch 字符串

从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：

```java
    public class Candy6_1 {
        public static void choose(String str) {
            switch (str) {
                case "hello": {
                    System.out.println("h");
                    break;
                }
                case "world": {
                    System.out.println("w");
                    break;
                }
            }
        }
    }
```

- 注: switch 配合 String 和枚举使用时，**变量不能为null**，原因分析完语法糖转换后的代码应当自然清楚

字节码转换: 

```java
            public static void choose(String str) {
                byte x = -1;
                
                switch(str.hashCode()) {
                    case 99162322: // hello 的 hashCode, 基本数据类型
                        if (str.equals("hello")) {
                            x = 0;
                        }
                        break;
                    case 113318802: // world 的 hashCode
                        if (str.equals("world")) {
                            x = 1;
                        }
                }
                // 两个 switch 解耦
                switch(x) {
                    case 0:
                        System.out.println("h");
                        break;
                    case 1:
                        System.out.println("w");
                }
            }
```

### 2.7 枚举类

JDK 7 新增了枚举类，以前面的性别枚举为例：

```java
enum Sex {
   MALE, FEMALE
}
```

字节码转换:

```java
 public final class Sex extends Enum<Sex> {
        public static final Sex MALE;
        public static final Sex FEMALE;
        private static final Sex[] $VALUES;

        static {
            MALE = new Sex("MALE", 0);
            FEMALE = new Sex("FEMALE", 1);
            $VALUES = new Sex[]{MALE, FEMALE};
        }

        private Sex(String name, int ordinal) {
            super(name, ordinal);
        }
     
        public static Sex[] values() {
            return $VALUES.clone();
        }
     
        public static Sex valueOf(String name) {
            return Enum.valueOf(Sex.class, name);
        }
    }
```

### 2.8 try-with-resources

JDK 7 开始新增了对需要关闭的资源处理的特殊语法try-with-resources`：

```java
try(资源变量 = 创建资源对象){

} catch( ) {

}
```

其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、OutputStream 、
Connection 、Statement 、ResultSet 等接口都实现了 AutoCloseable ，使用 try-with-resources
可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：

```java
public class Candy9 {
	public static void main(String[] args) {
		try(InputStream is = new FileInputStream("d:\\1.txt")) {
			System.out.println(is);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

字节码转换:

```java
    public static void main(String[] args) {
        try {
            InputStream is = new FileInputStream("d:\\1.txt");
            Throwable t = null;
            try {
                System.out.println(is);
            } catch (Throwable e1) {
                // t 是我们代码出现的异常
                t = e1;
                throw e1;
            } finally {
                // 判断了资源不为空
                if (is != null) {
                    // 如果我们代码有异常
                    if (t != null) {
                        try {
                            is.close();
                        } catch (Throwable e2) {
                            // 如果 close 出现异常，作为被压制异常添加
                            // 两个异常信息都会被抛出,不会丢失
                            t.addSuppressed(e2);
                        }
                    } else {
                        // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e
                        is.close();
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

### 2.9 方法重写时的桥接方法

我们都知道，方法重写时对返回值分两种情况：

- 父子类的返回值完全一致
- 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）

```java
class A {
    public Number m() {
        return 1;
    }
}
class B extends A {
    @Override
    // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类
    public Integer m() {
        return 2;
    }
}
```

字节码转换:

```java
class B extends A {
    public Integer m() {
        return 2;
    }
    // 此方法才是真正重写了父类 public Number m() 方法
    public synthetic bridge Number m() {
        // 调用 public Integer m()
        return m();
    }
}
```

其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突.



### 2.10 匿名内部类

源代码：

```java
    public class Candy11 {
        public static void main(String[] args) {
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    System.out.println("ok");
                }
            };
        }
    }
```

字节码转换:

```java
    // 额外生成的类
    final class Candy11$1 implements Runnable {
        Candy11$1() {
        }
        public void run() {
            System.out.println("ok");
        }
    }

	public class Candy11 {
		public static void main(String[] args) {
			Runnable runnable = new Candy11$1();
		}
	}
```



引用局部变量的匿名内部类，源代码：

```java
    public class Candy11 {
        public static void test(final int x) {
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    System.out.println("ok:" + x);
                }
            };
        }
    }
```

字节码转换:

```java
    // 额外生成的类
    final class Candy11$1 implements Runnable {
        int val$x;
        Candy11$1(int x) {
            this.val$x = x;
        }
        public void run() {
            System.out.println("ok:" + this.val$x);
        }
    }
    
    public class Candy11 {
        public static void test(final int x) {
            Runnable runnable = new Candy11$1(x);
        }
    }
```

注意: 这同时解释了为什么匿名内部类引用局部变量时，**局部变量必须是 final 的**：因为在**创建**
**Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性**，所以 x 不应该再发生变
化了，如果变化，那么 val$x 属性没有机会再跟着一起变化



## 3.类加载阶段

![image-20220822193608849](D:\A.学习资料\A.笔记\1. JVM\assets\image-20220822193608849.png)

### 3.1 加载(狭义上的加载)

#### 加载的理解

- 所谓加载，简而言之就是**将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型 - 类模板对象**。所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。
- 反射的机制即基于这一基础。 如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。

#### 加载完成的操作

加载阶段，简言之，**查找并加载类的二进制数据，生成Class的实例。**在加载类时，Java 虚拟机必须完成以下3件事情:

- 通过类的全名，获取类的二进制数据流。
- 将类的二进制数据流解析为方法区内的数据结构( Java 类模型)
- 创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口

##### 二进制流的获取方式

(只要二进制数据时符合字节码规范)

- **虚拟机通过文件系统读入一个 class 后缀的文件**
- **读入 jar,zip 等归档数据包,提取类文件**
- 网络加载等

获取到类的二进制信息后, Java 虚拟机就会处理这些数据,并最终转换为一个 java.lang.Class 的实例

##### 类模型位置

方法区(1.8 之前在永久代, 1.8 之后在元空间(本地内存))

##### Class实例的位置

类将 .class 文件加载至元空间后，会在堆中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。

如图:

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220822202650531.png" alt="image-20220822202650531" style="zoom:50%;" />

- 外部可以通过访问代表 0rder 类的 Class 对象来获取 Order 的类数据结构。

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220822203956367.png" alt="image-20220822203956367" style="zoom:50%;" />

Class 对象调用 getField() 等方法时,实际是从方法区中获取

### 3.2 链接

#### 1) 验证

验证类是否符合 JVM规范，安全性检查

#### 2) 准备

为 static **变量**分配空间，设置默认值(静态变量跟随 Class 对象,存储在堆中)

- static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾
- static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成
- 如果 **static final 的基本类型(静态常量)**，以及 **静态字符串常量**，那么编译阶段值就确定了，赋值在准备阶段完成,如果 static final 的引用类型，那么赋值也会在初始化阶段完成

#### 3) 解析

将常量池中的符号引用解析为直接引用

也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。

### 3.3 初始化

#### 1) 初始化过程

类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即: **到了初始化阶段，才真正开始执行类中定义的 Java 程序代码**。)

初始化阶段的重要工作是执行类的初始化方法: <clinit>() 方法

- 该方法**仅能由 Java 编译器生成并由 JVM 调用**，程序开发者无法自定义一个同名的方法，更无法直接在Java 程序中调用该方法，虽然该方法也是由字节码指令所组成。
- **它是由类静态成员的赋值语句以及 static 语句块合并产生的。**

注: 虚拟机会保证 <clinit>() 方法的线程安全性,带隐式的锁

#### 2) 初始化时机 

概括得说，类初始化是【懒惰的】

- main 方法所在的类，总会被首先初始化
- 首次访问这个类的静态变量或静态方法时
- 子类初始化，如果父类还没初始化，会引发
- 子类访问父类的静态变量，只会触发父类的初始化
- Class.forName
- new 会导致初始化

不会触发初始化的情况

- 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化
- 类对象.class 不会触发初始化
- 创建该类的数组不会触发初始化
- 类加载器的 loadClass 方法
- Class.forName 的参数 2 为 false 时

### 3.4 类的使用

开发者开发阶段都是在使用类

### 3.5 类的卸载

#### 类与实例,类与类加载器之间的关系

类与实例:

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220823113205458.png" alt="image-20220823113205458" style="zoom:67%;" />

类与类加载器:

在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader() 方法， 就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加
载器之间为双向关联关系。

#### 方法区的垃圾回收

方法区的垃圾收集主要回收两部分内容:**常量池中废弃的常量和不再使用的类型。**

HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

判定一个常量是否“废弃”还是相对简单，而要**判定一个类型是否属于“不再被使用的类”**的条件就比较苛刻了。需要同时满足下面三个条件:

- 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。



## 4.类加载器

类加载器是 JVM 执行类加载机制的前提

### 4.1 ClassLoader 的作用

ClassLoader 是 Java 核心组件,所有的 Class 都是由 ClassLoader 进行加载的, ClassLoader 负责通过各种方式将 Class 信息的二进制数据流读入 Jvm 内部,转换为一个与目标类对应的 java.lang.Class 对象的实例,然后交给 Java 虚拟机进行链接,初始化,等操作.因此, ClassLoader 在整个装载阶段,只能影响到类的加载,而无法通过 ClassLoader 去改变类的链接状态和初始化行为.至于是否可以运行,由执行引擎决定.

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220823122421587.png" alt="image-20220823122421587" style="zoom:67%;" />

### 4.2 类加载器分类

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220823123555191.png" alt="image-20220823123555191" style="zoom:67%;" />

- 除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。
- 不同类加载器看似是继承(Inheritance)关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用

#### 1) 启动类加载器(引导类加载器,Bootstrap ClassLoader)

- 加载核心库,加载扩展类加载器和应用程序类加载器,并指定他们的父类加载器

- 使用 C/C++ 语言实现,嵌套在 JVM 内部

- 用来加载 Java 的核心库 (JAVA_ HOME/jre/lib/rt.jar或sun.boot.class.path) 路径下的内容,用于提供 JVM 自身需要的类

- 不继承自 ClassLoader ,没有父类加载器

  

#### 2) 扩展类加载器(Extension ClassLoader)

- 用来加载 Java 的扩展库

- Java 语言编写
- 继承于 ClassLoader 类
- 父类加载器为启动类加载器
- 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。

#### 3) 应用程序类加载器(Application ClassLoader)

- 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库

- java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现
- 继承于 ClassLoader 类
- 父类加载器为扩展类加载器
- 应用程序中的类加载器默认是系统类加载器。
- 它是用户自定义类加载器的默认父加载器
- 通过 ClassLoader 的 getSystemClassLoader() 方法可以获取到该类加载器

#### 4) 用户自定义类加载器

- 在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。
- 体现 Java 语言强大生命力和巨大魅力的关键因素之一便是, Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 JAR 包，也可以是网络上的远程资源。
- 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的 OSGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。
- 同时，自定义加载器能够实现**应用隔离**，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器
- 自定义类加载器通常需要继承于ClassLoader。

步骤: 

1. 继承 ClassLoader 父类
2. 要遵从双亲委派机制，重写 findClass 方法
    注意不是重写 loadClass 方法，否则不会走双亲委派机制
3. 读取类文件的字节码
4. 调用父类的 defineClass 方法来加载类
5. 使用者调用该类加载器的 loadClass 方法

实例:

```java
class MyClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {

            String path = "class 文件路径";
            //获得字节码文件的输入流
            // ....
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Files.copy(Paths.get(path), os);

            byte[] bytes = os.toByteArray();
            // bytes -> *.class
            return defineClass(name, bytes, 0, bytes.length);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}


// 测试

  public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException,    InstantiationException, IllegalAccessException {
        MyClassLoader loader = new MyClassLoader();
        Class<?> test = loader.loadClass("org.snbo.complier.TestMain");

        Field a = test.getField("a");
        Field b = test.getField("b");
        //静态变量
        System.out.println(a.get(test));
        //静态变量
        System.out.println(b.get(test));
    }
```



### 4.3 双亲委派模型

定义: 

如果一个类加载器在接到加载类的请求时，它首先**不会自己尝试去加载这个类**，而是把这个请求任务委托给父加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。**只有父类加载器无法完成此加载任务时，才自己去加载。**

- 规定了类加载的顺序是:引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。

<img src="D:\A.学习资料\A.笔记\1. JVM\assets\image-20220823170532333.png" alt="image-20220823170532333" style="zoom:67%;" />

#### 1) 双亲委派机制优势

- 避免类的重复加载,确保一个类的全局唯一性(Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次)
- 保护程序安全,防止核心 API 被随意篡改

#### 2) 代码支持

双亲委派机制在 java.lang.ClassLoader.loadClass (String, boolean) 接口中体现。该接口的逻辑如下:

1. 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。
2. 判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass(name, false) 接口进行加载。
3. 反之，如果当前加载器的父类加载器为空，则调用 findBootstrapClassOrNu1l(name) 接口，让引导类加载器进行加载。
4. 如果通过以上3条路径都没能成功加载，则调用findClass (name )接口进行加载。该接口最终会调用
   java.lang.ClassLoader 接口的 defineClass 系列的 native 接口加载目标 Java 类。
   双亲委派的模型就隐藏在这第2和第3步中。

#### 3) 双亲委派机制劣势

委托过程是单向的,上层 ClassLoader 无法访问下层 ClassLoader 所加载的类

结论:

由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。

### 4.4 线程上下文类加载器

我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写

```java
Class.forName("com.mysql.jdbc.Driver")
```

也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？

让我们追踪一下源码：

```java
public class DriverManager {
	// 注册驱动的集合
	private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers
	= new CopyOnWriteArrayList<>();
	// 初始化驱动
	static {
		loadInitialDrivers();
		println("JDBC DriverManager initialized");
    }
}
```

先不看别的，看看 DriverManager 的类加载器：

```java
System.out.println(DriverManager.class.getClassLoader());
```

打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但
JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在
DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？

继续看 loadInitialDrivers() 方法：

```java
   
   private static void loadInitialDrivers() {
        String drivers;
        try {
            drivers = AccessController.doPrivileged(new PrivilegedAction<String>
                    () {
                public String run() {
                    return System.getProperty("jdbc.drivers");
                }
            });
        } catch (Exception ex) {
            drivers = null;
        }
        // 1）使用 ServiceLoader 机制加载驱动，即 SPI
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                ServiceLoader<Driver> loadedDrivers =
                        ServiceLoader.load(Driver.class);
                Iterator<Driver> driversIterator = loadedDrivers.iterator();
                try{
                    while(driversIterator.hasNext()) {
                        driversIterator.next();
                    }
                } catch(Throwable t) {
                // Do nothing
                }
                return null;
            }
        });
        println("DriverManager.initialize: jdbc.drivers = " + drivers);
        // 2）使用 jdbc.drivers 定义的驱动名加载驱动
        if (drivers == null || drivers.equals("")) {
            return;
        }
        String[] driversList = drivers.split(":");
        println("number of Drivers:" + driversList.length);
        for (String aDriver : driversList) {
            try {
                println("DriverManager.Initialize: loading " + aDriver);
                // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器
                Class.forName(aDriver, true,
                        ClassLoader.getSystemClassLoader());
            } catch (Exception ex) {
                println("DriverManager.Initialize: load failed: " + ex);
            }
        }
    }
```

- 先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此
  可以顺利完成类加载
- 再看 1）它就是大名鼎鼎的 Service Provider Interface （SPI）
  约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名名为文件，文件内容是实现类名称

![image-20220824202335431](D:\A.学习资料\A.笔记\1. JVM\assets\image-20220824202335431.png)

这样就可以使用

```java
ServiceLoader<接口类型> allImpls = ServiceLoader.load(接口类型.class);
Iterator<接口类型> iter = allImpls.iterator();
while(iter.hasNext()) {
    iter.next();
}
```

来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：

- JDBC
- Servlet 初始化器
- Spring 容器
- Dubbo（对 SPI 进行了扩展）

线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由
Class.forName 调用了线程上下文类加载器完成类加载.

总结: 虽然 DiverManager 是由启动类加载器加载的,但是内部加载 Mysql 驱动的时候,用了线程上下文类加载器(默认为应用程序类加载器)来加载,即打破了双亲委派机制



## 5.运行期优化

### 5.1 即时编译

#### 分层编译

JVM 将执行状态分成了 5 个层次：

- 0 层，解释执行（Interpreter）
- 1 层，使用 C1 即时编译器编译执行（不带 profiling）
- 2 层，使用 C1 即时编译器编译执行（带基本的 profiling）
- 3 层，使用 C1 即时编译器编译执行（带完全的 profiling）
- 4 层，使用 C2 即时编译器编译执行

profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的
回边次数】等

##### 即时编译器（JIT）与解释器的区别

- 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行**重复的解释**
- JIT 是将一些字节码编译为机器码，**并存入 Code Cache，下次遇到相同的代码，直接执行，无需**
  **再编译.** 
- 解释器是将字节码解释为针对所有平台都通用的机器码
- **JIT 会根据平台类型，生成平台特定的机器码**

对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运
行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速
度。 执行效率上简单比较一下 Interpreter < C1 < C2，总的目标是发现热点代码（hotspot名称的由
来）

#### 逃逸分析

发现新建的对象是否逃逸(有些新建的对象并没有在别处使用)。如果发现逃逸,会省略不新建

可以使用 -XX:-DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果

#### 方法内联

```java
private static int square(final int i) {
	return i * i;
}
```

```java
System.out.println(square(9));
```

如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、
粘贴到调用者的位置：

```java
System.out.println(9 * 9);
//进一步对常量进行优化
System.out.println(81);
```

#### 字段优化

...

### 5.2 反射优化
