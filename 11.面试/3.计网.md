### 计网基础



#### OSI 七层模型和 TCP/IP 四层模型?

OSI 有七层网络模型, 自底向上分别是 物理层 -> 数据链路层 -> 网络层 -> 传输层 -> 会话层 -> 表示层 -> 应用层

TCP/IP 四层网络模型, 自底向上分别是 网络接口层 -> 网络层 -> 传输层 -> 应用层



#### 点到点和端到端

点到点是主机和主机之间的通信, 属于网路层和数据链路层的概念

端到端是进程到进程之间的通信, 属于传输层的概念



### 传输层



#### TCP 和 UDP 的区别?

- TCP 是面向连接的, 在传输之前需要先建立连接. UDP 传送数据不需要建立连接.
  - 因为此特性, UDP 支持单播多播广播, TCP 支持单播
  
- 是否可靠传输: TCP 会提供面向连接的可靠传输服务, UDP 不提供可靠连接, 会进行错误检验, 有误后直接丢弃

- 由于 TCP 需要保证可靠传输, 需要建立连接, 有确认重传等机制. 所以它的传输效率要比 UDP 低很多

- TCP 是面向字节流传输, UDP 是面向数据报文传输

  

#### TCP 首部格式?

源端口和目的端口

序号: 用于对字节流进行编号, 如果序号为 100, 表示数据第一个字节的编号是 100, 如果携带的数据长度是100, 那么下次发送的报文段的序号就是 200

确认号: 确认号是希望收到的下一个报文段序号. 

数据偏移: 数据部分距离报文段起始处距离, 实际是首部长度

窗口: 窗口在流量控制时会作为接收方发送窗口的依据.



#### TCP 连接的建立?

1. 首先发送方向接收方发送 SYN 连接请求数据报, 带有数据的 seq 序号 x (第一次的 seq 序号是随机产生的, 随机是为了网络安全, 避免序号被获取. 一个 SYN 占用一个序号), 然后进入 SYN_SEND 状态, 等待接收方确认.
1. 接收方接收到 SYN 请求后, 返回一个 SYN = 1, ACK=1 的数据报, ACK 来确认发送方的信息. 同时自己也发送一个 SYN. SYN 是建立从接收方到发送方的通信. 也会初始化一个随机的序号 y, 确认号 ack 为 x+1
1. 最后发送方在发送一个 ACK=1 确认报文段, 序号 x+1, 确认号 y+1 发送方进入ESTABLISHED 状态, 接收方收到确认报文段后也进入 ESTABLISHED 状态, 连接建立



#### 为什么要三次握手?

为了确认接收双方收发数据的能力

第一次握手: 接收方知道: 对方发送正常, 自己接收正常

第二次握手: 发送方知道: 自己发送和接收正常, 对方发送和接收正常 接收方只知道对方发送正常, 自己接收正常, 并不知道自己发送和对方接收是否正常

第三次握手: 双方都知道自己和对方收发正常



#### 两次握手不行吗? 

两次握手可能会有长时间滞留在网络中的连接请求在连接关闭后又到达接收端, 从而导致错误. 如果是三次握手, 在接收端接收到请求后发送 ACK 确认应答, 但是客户端不会回复, 接收方重发一定次数后就会关闭连接



#### SYN 泛洪攻击?

利用了 TCP 协议的缺陷, 通过发送大量的半连接请求, 消耗 CPU 和内存资源. 攻击者发送大量的 SYN 报文段, 但是不会完成第三次握手的过程, 服务器就有大量的连接处于半连接状态, 消耗服务器的资源.

防御措施: 

syn cookie : 在接收到 SYN 请求的时候不会直接生成半连接, 而是根据这个 SYN 数据报生成一个 cookie 响应给客户端, 如果是正常连接客户端将会返回确认号为 cookie + 1 的报文段, 服务器通过报文的源 IP, 目的 IP 和端口号用函数计算出一个结果, 如果这个结果等于确认号的值, 证明是正常连接, 才会开启半连接状态. 



#### TCP 的四次挥手?

假设客户端 a 是先主动断开的一方, b 是被动断开的一方

1. 主动断开的一放 a 发送一个 FIN 连接释放报文, 序号 x, 确认号 y
2. b 收到释放报文后返回 ACK 确认报文. 此时 TCP 处于半关闭状态, b 可以给 a 发数据, a 不能给 b 发 
3. 当 b 也发送完数据不再需要连接时, 发送连接释放报文 FIN
4. a 收到连接释放报文后, 返回确认报文 ACK, 并进入 TIME-WAIT 状态. 等待两倍的最大报文存活时间后连接释放



#### 四次挥手的原因

因为 TCP 是全双工通信, 每个方向的连接都要单独关闭. 关闭连接的时候, 服务器收到对方的 FIN 报文说明对方没有发送数据的请求了, 但是服务器可能还有数据没有发送完. 所以要分两次来关闭连接.



#### 为什么要有 TIME-WAIT

1. 如果最后客户端的的确认关闭请求服务端没有接收到, 触发了超时重传后服务端会再次发送一个请求关闭报文 FIN, 这时客户端就可以重新发送确认报文, 然后重启 TIME-WAIT. 如果没有 time-wait, 服务端就会一直重发请求.
2. 还有一个原因就是, 两倍的最大报文传输时间可以保证本次连接中产生的所有报文段都从网络中消失



#### TCP 如何保证可靠传输?

TCP 保证可靠性的方式主要有: 

1. 校验和: TCP 会保证它首部和数据的校验和, 如果收到的校验和有差错, TCP 将会丢弃此报文段
2. 序列号和确认应答: TCP 对每个字节的数据都进行了编号, 这就是序列号, 当接收方收到数据后会对发送方进行确认应答, 这个应答报文段中包含了确认号, 即下次期望收到的报文段序号. 这样发送方就知道接收方已经收到了那些数据
3. 超时重传: 由于序号和确认应答机制, 发送发可以根据确认号来判断对方是否正确接收了数据, 然后就设置了超时重传机制, 也就是每次发送数据后设置一个超时重传时间, 当超过这个时间还没有收到确认信号, 发送发就会重传数据. 超时重传的时间应该略大于往返时间 RTT
4. 流量控制: 接收端的接收能力有限, 如果发送放无限制的发送数据, 超过接收方能处理的速度时, 就会造成数据的丢失, 流量控制就是让发送方发送数据的速率不要太快, 让接收方来得及接收. TCP 的流量控制是基于滑动窗口来实现的. 
5. 拥塞控制: 拥塞控制就是在网络拥堵的时候减少数据的发送, 避免造成更大的拥堵



#### TCP 如何实现流量控制?

TCP 利用滑动窗口来实现流量控制, 窗口是缓存的一部分, 用来暂时存放字节流(失序的数据也会暂时放在缓存区里), 发送方和接收方各有自己的窗口. 接收方通过 TCP 报文段中的窗口字段告诉发送方自己的接收窗口的大小, 发送方根据这个值来设置自己的发送窗口的大小. 发送窗口内的数据允许被发送. 发送窗口左边的数据已发送并已经收到确认后, 滑动窗口就可以向后移动. 接收窗口也是同理, 左边的数据已经交付后便可以向后滑动. 窗口的大小是一个动态变化的值, 当窗口值为 0 时, 发送方会暂时停止发送.



#### TCP 如何实现拥塞控制?

发送方拥有一个拥塞窗口, 它的大小取决于网络的拥塞程度, 并且是动态变化的. 发送方发送窗口的大小取拥塞窗口和接收窗口中较小的那一个. 

TCP 采用了四种拥塞控制的算法: 慢开始, 拥塞避免, 快重传和快恢复

慢开始: 由小到大逐渐增加拥塞窗口的大小, 初始值为 1, 每次都加倍. 慢开始并不是指增长慢, 大于慢开始门限后开始拥塞避免

拥塞避免: 拥塞避免是让拥塞窗口缓慢的线性增长. 每次 RTT 加一

快重传: 快重传是为了让发送方尽早知道有数据丢失, 接收方每收到失序的报文段就立即发出重复确认, 而不是等到自己发数据时才捎带确认. 如果接收方收到三个连续的重复确认就立即重传确实报文段. 并将慢开始门限减半, 让拥塞窗口大小等于慢开始门限, 开始拥塞避免算法



### 应用层

#### 什么是 DNS, DNS 解析流程?

DNS 域名解析协议, 它将域名转换为相应的 IP 地址. 域名分为根域名, 顶级域名, 权威域名, 本地域名. 每一级域名都有自己对应的服务器.

DNS 解析的流程一般是: 

1. 首先会查找浏览器和操作系统的本地缓存
2. 都没有记录的话, 主机会像本地 DNS 服务器发送 DNS 请求
3. 本地 DNS 服务器查询自身缓存, 有记录直接返回
4. 本地 DNS 也没有记录的话会直接发送请求给根域名服务器
5. 根域名服务器返回相应的顶级域名服务器地址
6. 本地 DNS 服务器接收到响应后向相应的顶级域名服务器发送 DNS 请求, 顶级域名服务器查询自身缓存, 如果没有相应记录的话就返回相关的下一级域名服务器的地址
7. 本地 DNS 服务器根据返回地址发送请求, 重复这个步骤直到获取到对应的 IP 地址并将其缓存, 然后将结果返回给主机



- 客户端和本地 DNS 服务器之间是递归查询, 本地 DNS 服务器和其他 DNS 服务器之间的查询是迭代查询
- DNS 服务一般使用 UDP 协议传输, 当传输大于 512 字节的数据时, 使用 TCP 协议



#### 文件传输协议 FTP?

FTP 使用 TCP 进行连接, 它使用两个连接来传送一个文件. 分为控制连接和数据连接

控制连接: 服务器打开端口 21 等待客户端的连接, 客户端主动建立连接后, 使用这个连接将客户端的命令发送给服务器, 并传回服务器的应答.

数据连接: 用来传送文件数据



#### 动态主机配置协议 DHCP?

DHCP 提供了即插即用的连接方式, 不需要用户手动的配置 IP 地址等信息, 而是由 DHCP 服务器为主机动态的配置 IP 地址, 子网掩码等.

分配过程如下: 

1. 客户端发送 DHCP 服务发现报文, 使用广播目的地址:255.255.255.255:67, 本主机源 IP 地址 0.0.0.0:68, 使用 UDP 协议进行发送, 该报文被广播到子网上.
2. DHCP 服务器收到 DHCP 发现报文后, 也用广播的形式返回响应. 因为客户端可能收到多个服务器的响应, 因此客户端需要进行选择.
3. 如果客户端选择了某个 DHCP 服务器提供的信息, 就发送一个 Request 请求报文给该服务器
4. 服务器收到 Request 请求报文, 返回 ACK 确认报文给客户端
5. 客户端收到 ACK 确认报文后就可以正常使用了.



#### 电子邮件协议?

一个电子邮件系统由三部分组成: 用户代理, 邮件服务器, 邮件协议

邮件协议分为发送协议和读取协议: 发送协议常用 SMTP, 读取协议常用 POP3 和 IMAP 协议.  

用户使用 SMTP 协议发送邮件到发送方邮件服务器(比如 163 邮件服务器),  发送方邮件服务器使用 SMTP 协议发送邮件到接收方邮件服务器(QQ 邮件服务器), 接收方邮件服务器通知用户, 用户通过 POP3/IMAP 协议将邮件取出

SMTP 和 POP3, IMAP 协议都使用 TCP 连接.

SMTP 只能发送 ASII 码, 互联网邮件扩充协议 MIME 增加了邮件主体结构, 定义了非 ASCII 码的编码规则.

POP3 的特点是用户读取文件后就从服务器上删除邮件, 最新版的不会删除

IMAP 协议中客户端和服务器的邮件保持同步, 不手动删除服务器也不会删除邮件.





#### 什么是 DNS 劫持?

劫持 DNS 服务器, 修改域名的解析结果, 导致对该域名的访问跳转到指定 IP, 结果就是对网址不能正常访问.



#### 什么是 DNS 污染?

由于 DNS 服务是没有认证的, 并且通常是基于 UDP 协议的不可靠连接. 通过伪装成目标 DNS 服务器, 返回给用户虚假的结果. 直接从协议上对用户的 DNS 请求进行干扰.



#### 输入 URL 到页面加载的过程?

1. DNS 解析过程: 由域名到 IP 地址依次经历了浏览器缓存, 操作系统缓存, 路由器缓存, DNS 服务器查询等一些列过程得到 IP 地址
2. 建立 TCP 连接(三次握手)
3. 浏览器发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染画面
6. 结束连接(四次挥手)

这中间可能还有 DHCP 配置主机 IP 信息, ARP 解析 MAC 地址



### 网络层

#### IP 数据报格式?

版本: 

首部长度:

首部校验和:

上层协议:

生存时间: 

总长度:



#### IP 地址编址方式?

分类, 子网划分, 无分类编址

子网划分: 在主机号中拿一部分作为网络号, 将两级 IP 地址划分为三级 IP 地址 <网络号><子网号><主机号>

无分类编址取消了传统的 ABC 类编址, 使用网络前缀和主机号来对 IP 地址编码



#### 地址解析协议 ARP?

ARP 协议主要解决的是从 IP 地址到数据链路层地址 MAC 地址的转换, IP 数据报的源地址和目的地址始终不变, 而 MAC 地址随着链路的改变而改变.

在局域网内每个网络设备都维护自己的一个 ARP 表, 里面记录了 IP 地址对应的 MAC 地址, 还包括 TTL 过期时间. 如果是在同一个局域网内进行地址转换, 主机如果在自己的 ARP 表内没有找到相应的映射, 就会构造一个 ARP 查询分组, 在局域网内进行广播, 局域网内的其他主机收到该查询分组后会和自己的 IP 地址进行比对, 如果不是则丢弃, 如果是自己的 IP 地址, 就会返回给源主机一个响应, 告知其自己的 MAC 地址, 源主机会把这条映射信息记录到自己的 ARP 表中.

如果源主机和目的主机不在同一个局域网内, 源主机首先要通过 ARP 协议获取到路由器的 MAC 地址, 并将数据报发送给路由器数据报的目的 MAC 地址是路由器的 MAC 地址, 路由器根据目的 IP, 查询转发表, 将数据报转发到目的主机所在的子网中, 数据报到达目的主机的子网后, 路由器通过 ARP 协议获得目的主机的 MAC 地址, 并将数据报发送给目的主机



#### ICMP 网络控制报文协议?

用于在主机, 路由器之间传递控制消息, 当网络中数据报的传输出现问题时, 主机或设备就会向上层协议报告错误情况. 就是一个错误报告机制, 当数据报出现差错的时 ICMP 向源主机报告这个差错, 它不会纠正错误. ICMP 报文封装在 IP 数据报内, 作为 IP 数据报的数据部分在网络中传输. IP 数据报中包含了源 IP 和目的 IP, 所以出现差错的时候, ICMP 协议只能响源主机报告. 源主机可以根据 ICMP 的报告类型来判断是出现了哪种错误.

ICMP 的典型应用: ping 指令



#### 网络地址转换 NAT?

NAT 是网络地址转换, 它是在一个局域网内部使用内部的 IP 地址, 而内部的主机需要和外部通信时, 通过 NAT 协议转换为公网地址. 它很好的解决了 IP 地址短缺的问题. 内部网络对外部网络是不可见的. 路由器有一张 NAT 转换表, 每一个主机的 IP 地址都对应一个端口号, 当主机需要和外部通信时, 路由器接收到它的数据报, 将它数据报中的 IP 地址和端口号进行替换, 发送到公网中, 接收数据的时候在替换回去, 并发送给局域网内的相应主机. 



### HTTP

#### 请求报文的结构?

请求行: 请求方法, URL, HTTP 版本

请求头: 从第二行开始, 格式是 key:value 的形式, 请求头中会包含若干个属性, 每个属性占据一行, 服务器可以根据这些属性来获取客户端的相关信息. 

常见的有 

- HOST: 请求的主机 

- Connection:连接方式(长连接或短连接)

- Content-Type:媒体类型 表示方式: 主类型/子类型 如 text/html; application:json;

- Cookie:

  ​      `空行分割头和体`

请求体: 请求的主体内容



#### 响应报文结构?

响应行: HTTP 版本, 状态码 描述

响应头: 第二行开始, key:value 的形式, 响应头中包含若干属性, 每个属性占一行.

​         `空行分割头和体`

响应体:响应的具体内容



#### URL 和 URI?

URI 包含 URL, URL 用来定位资源, URI 除了包含 URI 还包含 URN 资源名称



#### HTTP 的请求方法?

GET, POST, PUT, DELETE



#### HTTP 常见状态码?

1XX: 信息性状态码, 表示请求正在处理 [客户端可以继续发送请求或忽略这个响应]

2XX: 成功状态码, 请求正常处理完毕 []

3XX: 重定向状态码, 需要进行一些附加操作来完成请求

4XX: 客户端错误代码, 服务器无法处理请求

5XX: 服务器错误代码, 服务器处理请求出错了	



#### HTTP 长链接?

HTTP 1.1 默认长链接. 并不是无限长, 超过指定时间会关闭连接



#### HTTP 1.0 1.1 2.0 区别?

1.0 无状态, 默认短连接

1.1 加入长链接, 支持断点传输

2.0 头部压缩, 并行传输, 二进制分帧



#### HTTP 和 HTTPS 的区别?

HTTP 使用明文进行通信, 不会进行身份验证, 报文内容可能会被篡改.

HTTPS 是为了解决这些问题, 它基于 HTTP, 但是额外的使用了 SSL/TLS 协议用来加密和安全验证.

使用 HTTPS 协议首先要申请到 CA 证书. 在建立连接前要先进行身份验证, 并且传输过程内容也需要加密, 使用的是密钥加密的方法.



#### 对称加密和非对称加密?

对称加密的意思是, 加密和解密都使用同一把秘钥, 它的特点是运算速度很快, 缺点是秘钥难以安全的传输给对方

非对称加密的意思是, 加密和解密使用不同的秘钥, 秘钥分为私钥和公钥, 私钥由自己保存, 公钥公开所有人都可以获得. 通信时发送方使用公钥进行加密, 接收方使用自己的私钥进行解密. 优点是可以安全的传输公开秘钥, 缺点是运算速度较慢

非对称加密除了可以用来加密通信还可以用来进行身份验证, 因为私钥只有自己持有, 其他人无法获取, 所有通过私钥加密的数据其他人无法复刻, 接收方收到数据后使用公钥进行解密就能验证身份. 



#### SSL 连接过程?

1. 在进行通信之前首先要对通信方的身份进行验证. 
2. 客户端发送请求, 表明自己支持的 SSL 协议版本, 并生成一个随机数
3. 服务端收到消息后确定加密算法, 返回数字证书(数字证书由 CA 机构颁布, 并附有数字签名), 还有随机生成的一个随机数
4. 客户端接收到消息后验证证书的合法性, 如果证书合法, 生成一个随机数, 然后使用数字证书中的公钥加密这个随机数发送给服务器
5. 服务器使用自己的私钥解密后得到随机数
6. 客户端和服务端使用约定好的加密算法, 使用之前生成的三个随机数生成秘钥用来加密后续的通信内容



#### 什么是数字签名?

数字签名是 CA 机构颁发证书时, 使用散列和加密的方式, 提供验证证书合法的方式

数字签名的过程是, 用散列技术对服务器的公钥生成一个摘要, 并使用 CA 机构自身的私钥对摘要进行加密, 添加在证书上. 客户端收到证书后, 使用 CA 的公钥对内容进行解密得到摘要, 然后使用相同的散列算法对服务器的公钥生成摘要, 将两次得到的摘要进行对比, 相同的话验证成功.



#### Socket 是什么?

Socket 是TCP/IP 网络的 API, 把复杂的协议族隐藏在 Socket 接口后面, 用户只需要调用接口即可建立一个 TCP 连接
