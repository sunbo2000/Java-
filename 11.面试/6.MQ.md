#### 为什么使用消息队列?

- 解耦
- 异步
  - 提高系统响应速度
- 削峰填谷: 将请求发送到队列列中，短暂的⾼高峰期积压是允许的。



#### RabbitMq 有哪些组件?

- broker: RabbitMq 的服务器, 由虚拟主机组成, 虚拟主机内包含了消息交换机和队列.
  - 虚拟主机: 隔离不同的环境, mini 的 rabbitmq
  - exchange: 交换机负责消息的路由
  - queue: 队列, 存储消息
- 连接管理器: 无论是生产者还是消费者都要和 broker 建立连接, RabbitMq 中的连接是建立在 TCP 之上的虚拟连接, 每个连接成为一个 Channel 消息通道. 
- 生产者, 消费者



#### RabbitMq 有哪些消息模型?

- 基本消息模型
  - BasicQueue: 一个消费者绑定一个队列

- 工作消息模型

  - WorkQueue: 一个队列可以被多个消费者绑定

- 发布订阅模型

  依靠交换机实现, 不同类型的交换机有不同的功能

  - Fanout: 广播, 会将消息路由给所有绑定了该交换机的队列
  - Direct: 定向路由, 队列和交换机绑定时要指定路由键, 发送消息时也要指定路由键, 交换机根据不同的路由键将消息路由到不同的队列 (生产者投递的消息被交换机路由到通过路由键绑定的特定队列)
  - Topic: 主题模式, 和定向路由的功能类似, 但是在定义路由键时可以使用通配符. 路由键一般由多个词用`.`分割, `#`匹配多个词 `*`只能匹配一个词



#### 如何保证消息的可靠性?

从消息发送到消息接收会经历多个过程, 消息可能在发送是丢失, mq 宕机丢失, 消费者没有成功消费消息都会造成消息丢失, 要保证可靠性就要保证这些过程都是可靠的.

1. 生产者确认机制

   - rabbitmq 提供了发布确认机制来避免消息在发送到 mq 的过程中丢失, 在发送消息的时候要指定消息的唯一 id(为了区分消息, 避免 ack 冲突), 开启发布确认机制后如果消息成功发送到 mq 会返回 ack, 如果消息没有投递到 mq 会返回 nack, 这时可以根据根据情况进行重试.
   - 除了 publisher-confirm 之外还有 publisher-return 发送消息回执, 如果消息投递到交换机后无法路由就会执行回执.(这里还可以使用备份交换机来减少生产者的负担,  消息无法路由就成了死信)

2. 持久化机制

   - 消息持久化, 交换机持久化, 队列持久化. 默认情况下消息,交换机,队列都是持久化的

3. 消费者的确认机制

   - none: 投递后就会删除
   - auto: 自动 ack
   - manual: 手动 ack

4. 消费失败重试机制

   - 如果设置了消息处理失败重新入队, 当消息消费出现异常时消息会不断重新入队, 再重新发送给消费者. 如果在异常又会重复入队. 这样有可能再次无限循环.

     - `如果不重新入队就成了死信`

   - 我们可以使用 spring 的 retry 机制, 当消费异常的时候先在本地重试几次, 本地重试都失败后根据失败策略进行下一步处理. 

     - 失败策略: 直接丢弃(默认), 重新入队(还是会可能出现无限循环), 投递到指定队列
     - 我们可以选择处理失败后投递到指定队列, 然后交给人工集中处理

     `也可以配合死信队列, 在丢弃后这条消息就成了死信, 把它投递到死信队列中集中处理也可以`



#### 什么是死信交换机?

死信: 

- 消费者消费失败, 并且没有设置重新入队
- 队列达到最大容量, 无法在添加数据
- 消息过期未消费

如果一个队列配置了死信交换机, 当队列中的消息成为死信后就会被投递到死信交换机中, 与死信交换机绑定的队列成为死信队列, 死信队列可以用来处理消费者消费失败的消息, 还可以配合 ttl 实现延时队列.



#### 如何实现延时队列?

1. 使用死信队列配合过期时间实现

- RabbitMq 可以给消息设置过期时间, 也可以给队列设置过期时间, 都可以实现延时队列. 区别是给消息设置过期时间可能会导致前面的消息未过期导致后面已过期的消息无法执行过期逻辑, 因为只会判断第一个消息是否过期. 给队列设置过期时间的话可以避免上面问题, 但过期的时间是固定的.

2. 使用插件实现

- 使用插件 DelayExchange, 该插件的原理是发消息到交换机的时候, 交换机读取延时时间, 并把消息持久化到硬盘, 延时时间到期后再将消息投递到队列中



#### 延时队列的应用场景?

- 延时发送短信
- 用户下单, 30 分钟未支付自动取消订单



#### 如何保证消息的顺序性?

1. 消费乱序一般是不同的消费处理了同一段逻辑的不同操作, 本该顺序执行但是不同消费者的处理速度不同导致出错(添加->删除 变成了 删除->添加). 解决方法是首先要将需要保持先后顺序的消息按序放到同一个消息队列中, 然后只使用一个消费者去消费. 性能差的话可以给交换机绑定多个队列, 每个队列绑定一个消费者.
2. 或者给消息添加一个全局的序号, 当消息到达消费者时消费者去判断当前消息是否是按序到达的消息, 如果不是就暂时不处理.



#### 交换机类型?

- fanout
- direct
- topic



#### 如何避免重复消费?

给每个消息生成一个 id

