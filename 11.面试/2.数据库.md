### 数据库基础



#### 数据库的三范式是什么?

第一范式: 确保每列的原子性

第二范式: 确保表中的每列都和主键相关

第三范式: 确保表中每列都和主键直接相关而不是间接相关



#### MySQL 基础架构?

连接器: 管理链接, 权限认证

缓存: 8.0 之后移除

分析器: 进行语法分析

优化器: 按照 MySQL 认为最优的方案去执行

执行器: 执行语句, 从存储引擎返回数据. 执行语句之前会先判断是否拥有权限, 没有权限会报错

存储引擎: 存储引擎主要负责数据的存储和读取, 采用插件式架构. 



#### MySql 有哪些存储引擎?

InnoDb, 特点: 支持事务, 支持行锁, 支持外键, 有崩溃后安全恢复能力(依赖于 redo log), 5.5 之后的默认存储引擎

MyIsam, 特点: 不支持事务, 支持表锁, 不支持外键, 不支持崩溃恢复



#### char 和 varchar?

char 固定长度最多存放 255 字节, 长度不够时会补上空格, 取数据是会去除空格

varchar 可变长度, 需要使用额外的一个或两个字节来存储长度





### 索引



#### 什么是索引?

索引是数据库用来高效搜索数据的一种数据结构, 它是在存储引擎层实现的, 所以不同的存储引擎有不同的实现



#### 索引的优缺点?

优点:

- 可以大大加快数据查询速度 

- 通过创建唯一性索引可以保证数据库表中每一行的唯一性

缺点:

- 创建索引和维护索引需要额外的消耗和额外的内存空间
- 在数据量小时, 索引并不一定会带来性能的提升



#### 索引的底层数据结构?

B+ 树, 一棵多路平衡查找树, 每一个结点都可存储多个 key, 它的非叶子结点不存储数据只存储 key, 叶子结点才真正的存储数据. 所有的叶子结点都在同一层并且是有序的, MySQL 索引数据结构对 B+ 树进行了优化, 所有的叶子结点行程一条双向链表

哈希表: o(1) 的查找时间, 但是失去了有序性. 无法用于范围查找

`InnoDb 引擎有一个特殊的自适应哈希, 当某个索引被访问的很频繁时会给它创建一个哈希索引`

全文索引: 用于查找文本中的关键词, 而不是直接比较是否相等



#### 为什么使用 B+ 树?

1. 数据库将索引的结点的大小设为一个页的大小(操作系统以页为单位与磁盘交换数据), 这样一次 IO 就可以载入一个结点的内容, 中每一页的大小是固定的, 相比于 B 树, 使用 B+ 非叶子结点中每一页可以存放更多的 key, 当保存相同数量的数据时, B 树的高度要高于 B+ 树, 增加了访问磁盘的次数, 效率降低
2. B+ 树的数据都存储在叶子结点中, 并且通过双向链表连接, 这样很方便做范围查询和排序



#### 索引的类型?

大的分类可以分为聚簇索引和非聚簇索引(二级索引)

聚簇索引:

- 聚簇索引也就是主键索引, 一张表只能有一个主键索引, 聚簇索引的叶子结点存储的是真正的数据. 如果表中不存在主键会使用第一个唯一索引创建聚簇索引, 如果表中也没有唯一索引那么 InnoDb 引擎会自动生成一个隐藏的列作为聚簇索引. 

非聚簇索引:

- 非聚簇索引也叫二级索引或者辅助索引, 非聚簇索引的叶子结点不存储数据, 而存储的是聚簇索引中的主键. 
- 非聚簇索引主要有:
  - 普通索引: 是基本的索引方式, 可以重复可以为 null
  - 唯一索引: 让索引的值唯一, 不能重复但可以为 null
- 还可以基于以上几种索引创建联合索引和前缀索引; 联合索引查询的时候遵循最左前缀原则, 前缀索引只能基于字符串(char, varchar, text)类型来创建



#### 什么是覆盖索引和回表?

当使用二级索引进行查找的时候要先找到主键的值, 在根据主键的值去聚簇索引中查询响应数据. 这个过程称为回表. 当需要查询的数据就包含在二级索引中的时候, 就无需进行回表操作直接返回查询数据, 这个叫做索引覆盖.



#### 为什么不都设置成聚簇索引?

因为这样维护聚簇索引的代价很大, 一单数据发生迁移改变就要改变所有索引结构.



#### 什么是索引下推?

索引下推的目的是减少二级索引的回表操作, 联合索引没有符合最左前缀原则的情况, 如果判断查询条件中有索引列的话会直接在存储引擎中进行判断, 符合条件的才会做回表操作.



#### 索引失效的情况?

- 使用 or 条件查询时, 存在一个查询条件没创建索引
  - 当 or 两边的查询条件都有索引时, 底层分别引用两个索引
  - 同一字段用 or 时会走索引
- 联合索引没有遵循最左前缀原则
- 使用 != 时
- Like 查询 %在前时
- 使用 not in, 并且不是覆盖索引的时候
- 发生了隐式的类型转换. 比如字符串类型不加引号
- 对字段进行函数操作时不会走索引
- 优化器觉得不走索引效率更高时



### 事务



#### 什么是事务?

事务是一组不可再分的原子操作, 当事务中的某个语句执行失败那么应该回到执行前的状态



#### 事务的特性(ACID)?

- 原子性: 事务被视为不可再分的最小单元, 事务的所有操作要么全部成功, 要么全部失败回滚.

- 隔离性: 一个事务在最终提交前对其他事务是不可见的
- 持久性: 事务一旦提交, 所做的修改就永久的保存在数据库中
- 一致性: 数据库在事务执行的前后保持一致性的状态.



#### 并发一致性问题?

- 丢失修改: 事务修改了数据, 但是被另一个事务的修改覆盖
- 脏读: 当前事务读取了其他事务修改但未提交的数据, 另一个事务如果撤销操作, 当前事务读到的数据就是脏数据
- 不可重复读: 在事务内两次查询操作的结果不一致, 因为中间有其他事务修改并提交了数据
- 幻读: 本质也是不可重复读, 查询操作的结果不一致, 因为中间有其他事务添加并提交了数据

产生并发一致性问题的主要原因是破坏了事务的隔离性, 数据库提供了事务的隔离级别来解决并发一致性问题



#### 事务的隔离级别?

- 读未提交: 一个事务一旦修改了数据, 对其他事务是可见的
- 读已提交: 一个事务提交之后, 所做的修改对其他事务是可见的
- 可重复读: 在同一个事务中多次读取到的数据的结果是相同的(InnoDb 的默认隔离级别)
- 可串行化: 强制事务串行执行, 让多个事务互不干扰



#### ACID 靠什么保证?

- 原子性由 undo log(回滚) 日志来保证, 它记录了需要回滚的信息
- 隔离性由 锁机制 和 MVCC 保证
- 持久性依赖 redo log(重做) 日志保证
- 通过原子性, 隔离性, 持久性共同保证一致性



#### 谈一谈 redo log 日志?

redo log 重做日志是 InnoDb 独有的日志, 它是用来保证事务的持久性, 让 MySQL 有了崩溃恢复的能力, 如果 MySQL 实例挂了或者宕机了, 重启时 InnoDb 引擎会通过 redo log 日志恢复数据, 保证数据的持久性.

当修改表数据时, 会将具体的修改后的数据写入到 redo log buffer 里, 然后在事务提交时根据不同的刷盘策略刷新的磁盘中.

有三种刷盘策略: 当刷盘策略设置为 0 时, InnoDb 有一个后台线程, 默认它会每秒钟将 redo log buffer 刷盘(也就是说没有提交的事务也可能会刷盘). 当刷盘策略设置为 1 时, 每次事务提交时就立刻刷盘, 这是默认的刷盘策略. 当刷盘策略为 2 时会把 redo log buffer 的内容交给 page cache 交给操作系统处理. 

为 0 时可能会有 1 秒的数据丢失, 为 1 时一致性最好, 不会有数据丢失. 为 2 时宕机的话可能会有 1 秒的数据丢失

`每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成`



#### redo log 日志文件组

redo log 日志文件不止一个, 是以日志文件组的形式出现的, 每个 redo log 日志文件的大小相同. 

日志文件组采用的是环形数组的形式有两个指针分别指向: 当前写入位置, 一边写一边后移

一个指向当前还未加载的位置. 每当加载 redo log 日志恢复数据的时候该该指针随之后移

两个指针中间的部分是可以写入的地方, 当写入指针追上记录指针时, 说明日志文件组满了, 这时不能在写入记录, 需要清空一部分记录在继续写入



#### 每次提交事务直接刷入磁盘就好了, 就不需要 redo log 了呀? 都是刷盘有何两样?

当然是不一样的, 数据页大小是 16 kb, 刷盘的时候是随机写, 会十分耗时, 可能就更改了一小部分数据, 却要大费周折. 而 redo log buffer 比数据页小的多, 并且是顺序写, 刷盘速度很快, 让它 MySQL 有了更强的并发能力

#### change buffer?

同理其实 MySQL 内存中还有一个结构加 change buffer, 当数据发生更改的时候, 如果 buffer pool 中有数据就直接在 buffer pool 中修改了, 如果没有的话会把更改的操作缓存在 change buffer 中, 下次该条数据被查询时进行合并, 系统也会在一定的时间进行刷盘. redo log 节省了随机写的 IO 消耗, change buffer 则是节省了随机读的 IO 消耗, 但是对于唯一索引是不能使用 change buffer 的, 因为是唯一的需要判断.



#### binlog 日志?

binlog 日志主要用来解决 MySQL 主从复制时的一致性问题

redo log 日志是物理日志, 记录了在什么位置做了什么样的修改, 属于 InnoDb 引擎.

binlog 日志属于逻辑日志, 记录的是语句的原始逻辑, "给 id = 2 的这行的 c 字段 加 1", 属于 服务层



#### 更新一条语句的过程?



1. 执行器之前的操作和查询是一样的, 连接, 分析, 优化(如果有缓存的话, 更新会清空缓存)

2. 首先从缓冲池查询数据, 如果没有查询到数据就先去磁盘查询加载到内存中, 在加载到 Buffer Pool 中的同时, 会记录 undo log 日志

3. 执行器调用存储引擎接口, 将修改后的结果更新到内存 Buffer Pool 中

   - 同时存储引擎会将这个修改记录会添加到 redo log 中(redo log 是 InnoDb 的), 并且将 redo log 设为准备状态.

4. 执行器记录 bin log 日志, 完成后调用事务提交接口, 并把 redo log 改成 commit 状态

   

#### 两阶段提交?

在事务提交的时候 InnoDb 引擎执行两阶段提交方案, 将 redo log 的写入分成了准备和提交两个阶段, 准备阶段是正常的 redo log 日志写入流程. 准备阶段完成后进行 binlog 日志的写入, binlog 日志写入完成后在将 redo log 才算提交完成.



#### 谈谈 undo log 日志?

undo log 日志的的目的是保证事务的原子性, 让事务有回滚的能力, undo log 是逻辑日志, 记录的是每个事务对数据执行的操作. 所有事务进行的修改都事先记录在回滚日志中, 然后再执行相关的操作.如果执行过程出现异常直接利用回滚日志将信息恢复到事务开始前的样子. 

undo log 日志还有一个功能是配合 隐藏字段, 读视图实现 MVCC



#### 什么是 MVCC, MVCC 的原理?

多版本并发控制, 用来解决读写冲突时的无锁并发控制, 可以在发生读写冲突时不用加锁解决. 这里的读指的是快照读

实现原理: 隐藏字段, undo log 日志, 读视图(Read View)

隐藏字段是除了我们定义得我字段外, 数据库隐式的定义了 BD_TRX_ID 操作该记录的事务 ID,

回滚指针: 它会指向对应的 ungo log 日志, undo log 日志的历史版本会通过指针连接成一个链表, 行成版本链

读视图: 是事务进行快照读的那一刻产生的当前系统的一个快照, 记录这当前系统的活跃事务 ID 集合, 最大最小事务 ID, 生成视图的事务 ID. (Read View 用以读已提交和可重复读隔离级别的实现)

进行读视图的时候根据取出 undo log 版本链的头结点中的事务 ID, 和读视图中的活跃事务 ID 进行可见性分析, 不可见就通过版本链取出下一个事务 ID, 依次比较, 第一个可见的事务 ID 所在的记录, 就是当前事务可见的最新记录

- 如果小于最小或者大于最大, 不可见
- 如果在最小和最大之间, 判断是否在列表中, 不在的话可见, 在的话不可见



#### 读已提交和可重复读的读视图?

读已提交隔离级别下的事务是每次查询的开始都生成读视图, 可重复读是在第一次读的时候生成读视图, 之后都复用第一次生成的读视图



#### 快照读和当前读?

快照读是的执行方式是生成 read view, 不会对记录加锁. 它是基于 MVCC , 读到的不一定是最新数据可能是某个历史数据. 当执行不加锁的 select 语句时, 执行的是快照读

当前读又叫加锁读(加的 next-key 临键锁), 读取的是数据库当前最新的数据, 可以对读取的数据进行加锁, 防止其他事务修改数据, 是悲观锁的一种操作, 读操作加共享锁或排它锁, 增删改数据, 串行化的事务隔离级别都是当前读



#### MVCC 能不能解决幻读?

有一种情况不能避免, 当前事务读取了数据后, 另一个事务插入了新数据并提交了, 当前事务执行了更新操作更新了新加入的数据. 那么当前事务再去读取数据的时候就会多出记录.

在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。



#### MySQL 的锁?

根据加锁的范围可以分为:

1. 全局锁(读锁): 锁住的数据库中的所有表

   - 加了全局读锁后整个实例就处于只读状态, 后续的 DDL 和 DML 都会被阻塞.
   - 缺点:
     - 全局锁是重量级的操作, 会导致业务直接停摆
     - 从库使用了全局锁在备份期间会造成主从延迟

2. 表级锁: 锁住的是一张表

   - 表锁可以分为共享锁, 独占锁, 意向锁

   - 共享锁就是读锁, 所有的事务只能读数据, 会阻塞其他事务的读操作 -- lock tables ** read

   - 排它锁也就是写锁, 当前事务可读可写, 会阻塞其他事务的读写操作 -- lock tables ** write

   - 元数据锁: 有系统自动控制, 在进行 DML 的时候会加元数据读锁, 在进行 DDL 操作的时候会加元数据写锁

   - 意向锁

     为了避免 DML 在执行时加的行锁与表锁的冲突, 在 InnoDb 引擎中加入了意向锁, 使得表锁不用检查每行数据是否加锁, 使用意向锁来减少表锁的检查.

     - 意向共享锁, 表示事务给某行数据加了共享锁, 它可以和表共享锁兼容, 和表的排它锁互斥
     - 意向排它锁, 表示事务给某行数据加了排他锁, 它和表的共享锁, 排它锁都互斥
     - 意向锁之间不会互斥

3. 行级锁: 锁住的是某一行锁定的粒度最小的一种锁, 只针对当前操作的记录进行加锁

   - 记录锁: 记录锁是给某条记录上锁, 实际上锁的是索引, 并不是记录本身. 读已提交和可重复读都支持

     - lock in share mode   ||  lock for update

   - 间隙锁: 锁定的是索引记录间隙(不包含该记录), 确保记录间隙不变, 防止其他事务在间隙内插入数据, 产生幻读. 间隙锁之间不会互斥

   - 临键锁: 临建锁时记录锁和间隙锁的组合, 同时锁住记录和间隙. 在可重复读的隔离级别下支持使用, 防止幻读.

     - 如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

       ```sql
       (-∞, 10]
       (10, 11]
       (11, 13]
       (13, 20]
       (20, +∞)
       ```

       



#### 什么是锁升级?

MySQL 的行锁是加在索引上的, 如果操作不走索引, 行锁就会升级为表锁. 也就是索引失效的时候就会造成锁升级



#### 什么是两阶段锁?

在 InnoDb 协议中, 行锁是需要的时候才加上的, 但是并不是不需要了就立刻释放, 而是要等到事务结束才会释放. 这就是两阶段锁协议.

这也提示我们, 在事务操作中, 将最有可能影响并发度的锁尽量往后放.



### SQL 优化

1. 主键最好采用数字类型并且是有序增长的(无序的话可能造成页分裂)
2. 对查询的优化, 大部分就是对索引优化. 尽量避免全表查询
3. 大量数据 limit 分页时可以使用索引来优化, order by 索引字段, 可以是主键,
4. 使用 order by 的时候尽量避免 useing filesort, 也就是利用索引. 多字段排序时要注意索引在创建时的规则 -- create index idx_user_age_phone_ad on tb_user(age asc, phone desc);
5. select count(*) from table; 会全表扫描, 要尽量避免, 如果非要使用, 尽量使用 count(\*) 在服务层对 count(\*) 做了优化, 不取值,直接累加
6. 只包含数字的字段尽量使用数字类型, 数字类型判断是只需要一次
7. 不使用 select * from table; 不返回没用的字段, 能覆盖索引尽量使用覆盖索引
8. 最好建立联合索引, 不要创建过多的索引
9. 将大的查询拆分开, 拆分成几个小的查询, 一个大的查询可能会锁住很多数据, 阻塞其他事务
