### 进程管理

#### 进程与线程?

进程是资源分配的基本单位, 线程是系统调度的基本单位. 

在同一进程中, 线程的切换不会造成进程的切换. 从一个进程的线程切换到另一个进程的的线程会造成进程的切换

创建或撤销进程的系统开销很大, 系统要为其分配资源, 像内存空间等. 类似的在进程进程切换时, 涉及当前执行进程 CPU 环境的保存和新进程 CPU 环境的设置, 而线程的切换只需要保存少量的寄存器信息, 开销很小.



#### 进程调度算法?

1. 先来先服务(FCFS)

   按照请求的顺序进行调度, 会一直运行到执行完成或者遇到阻塞, 是非抢占式的.

   特点是有利于长作业, 但是不利于短作业. 因为短作业要等到其前面的长作业执行完才能执行, 长作业执行的时间又很长, 造成短作业等待时间很长的情况

2. 短作业优先(SJF)

   会从就绪队列中选出估计的运行时间最短的作业为其分配资源, 一直执行直到完成或者发生阻塞, 是非抢占式的

   特点是有利于短作业但不利于长作业, 如果一直有短作业到来, 那长作业会一直得不到调度

3. 高响应比优先(HRRN)

   响应比是 (等待时间+要求服务时间)/要求服务时间,  随着等待时间的增加, 长作业的响应比会增大, 避饥饿. 

   特点是总和考虑的等待时间和运行时间, 但是不关心响应时间也不区分紧急程度, 所以对用户的体验较差

4. 时间片轮转(FCFS)

   按照各个进程到达就绪队列的顺序, 轮流的让每一个进程执行一个时间片, 如果进程没有在时间片内执行完, 就要停止它的执行, 放到就绪队列的队尾, 将时间片分给下一个进程. 是抢占式的.

   特点是公平轮流的为每一个进程服务, 但是高频的进程切换也会造成系统的开销.

5. 优先级调度

   为每个进程分配一个优先级, 按照优先级进行调度.

   缺点是低优先级的线程可能会长期分配不到资源, 可以随着等待时间的推移增加其优先级

6. 多级反馈队列

   设置了多级的就绪队列, 各个队列的优先级从高到低排列, 每个队列都有不同的时间片, 时间片从小到大排列. 新进程到达时先进入第 1 级队列, 按照时间片轮转调度等待分配时间片, 如果时间片用完进程还未执行结束, 则进入到下一级队列队尾. 如果已经是最下一级的队列, 就重新放在队尾. 只有上级队列为空时下级队列才会分配时间片. 是抢占式的.

   特点: 是时间片轮转调度和优先级调度的结合



#### 死锁的避免?

银行家算法, 当一个进程申请使用资源的时候，**银行家算法** 通过先 **试探** 分配给该进程资源，然后通过 **安全性算法** 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 **真的分配资源给该进程**。



#### 进程间的通信方式?

进程间的通信方式大概有

1. 管道: 管道的本质是内存中的一个缓冲区, 管道一端的进程顺序的像管道写入数据, 另一端的进程顺序的读数据, 管道是半双工通信, 只能一端读一端写.

   管道分为无名管道和有名管道, 无名管道只能在有亲缘关系的父子进程或兄弟进程间进行通信, 因为没有名字, 进程只能访问自己或祖先创建的管道. 

   命名管道和无名管道的区别是, 命名管道在磁盘中有一个对应的文件, 有了这个文件名, 所有对这个文件有访问权限的进程都可以使用该管道, 不在局限于亲缘关系的进程

2. 消息队列

   消息队列是消息的链表, 它存放在内存中. 用户可以向消息队列添加消息也可以读取消息. 同管道相比, 它的优势是每个消息都可以指定特定的类型, 接收的时候不需要按照队列的次序, 可以根据条件接收特定类型的消息.

3. 共享内存

   共享内存允许两个或多个进程共享一个给定的内存区域, 不同的进程可以及时看到对方进程中对共享内存中数据的更新. 因为共享内存是直接在物理内存上开辟了一块内存给各进程, 所以它的速度极快. 不需要像管道和消息队列那样调用内核态(在用户态写, 写完拷贝到内核态/从内核态拷贝到用户态, 用户程序去读).但是这种机制需要依靠同步操作,可以使用信号量等.

4. 信号量

   信号量是一个计数器, 和上面几个不同, 信号量可以用来实现进程间的互斥或同步问题, 用于多进程对共享数据的访问.

5. 套接字(Socket) : 主要用于不同主机之间的进程.

6. 信号(Single): 信号是一种比较复杂的通信方式, 用于通知接收进程某个时间已经发生



#### 线程间的通信方式?

进程间的通信方式主要有共享内存, 信号量, 消息传递, 管道流

共享内存: 

消息传递: 用于通知接收进程某个事假已经发生, 类似于 wait() / notifyAll().

信号量: 一个技术器, 可以用来实现线程间的同步或者互斥问题

管道流: 属于消息传递的方式, 用数据流在不同线程间传输数据



### 内存管理



#### 内存管理方式有哪些?

内存管理的方式主要有分页管理, 分段管理, 段页式管理

**分页管理**: 

- 将内存空间分为大小相等的分区, 每个分区是一个页框, 进程的逻辑地址空间也划分成与之相等的分区. 以页框为单位为各个进程分配内存空间, 各个页面不必连续存放, 可以放到不同的页框中. 分页实现了离散分配, 提高了内存利用率, 内存碎片少. 
- 分页管理需要页表来配合: 每个进程都分配一张页表, 页表记录了页号-块号 通过页表来转换逻辑地址和物理地址

> 页面起始地址 + 页内偏移量 == 逻辑地址 ---- 
>
> 页内偏移量: 页面大小--> 0 ~ 2^12
>
> 逻辑地址 / 页面大小 = 页号
>
> 逻辑地址 % 页面大小 = 页内偏移量
>
> 一个逻辑地址的前 m 为页号后 n 位为它的页内偏移量, 如果页面大小为 4KB, 那它的后 12 位就是页内偏移量

```
逻辑地址到物理地址的转化
根据逻辑地址算出页号---> 差页表得到块号--> 块号 + 页内偏移量 = 物理地址
逻辑地址的后 n 位为页内偏移量(2^n = 页面大小)
```

**分段管理**: 

- 分页管理虽然提高了内存利用率, 但是分页管理的页并没有实际的意义. 分段管理将内存分为大小不同的段, 每段都有自己的逻辑信息, 比如数据段, 代码段, 堆栈段信息等.

- 分段管理需要段表来配合: 段表中记录了进程的逻辑地址和对应的物理地址
- 缺点: 段过大的话容易产生外部碎片

**段页式**: 

- 段页式管理是结合了分段管理和分页管理的特点, 先将程序的地址空间按照逻辑划分为不同的段, 每个段上的空间又划分为大小相同的页.
- 段页式管理的段和段之间是离散的, 段内的页和页之间也是离散的. 不会产生外部碎片(段内是离散的了), 会产生内部碎片
- 需要配合段表和页表来使用



#### 分页和分段的区别?

相同点: 

- 分页和分段都是为了提高内存的利用率, 减少内存碎片
- 页和段都是离散分布的

不同点:

- 页是物理单位, 段是逻辑单位. 分页可以提高内存利用率, 分段可以更好的满足用户需求.

- 分页管理会产生内部碎片不会产生外部碎片, 分段管理会产生外部碎片不会产生内部碎片.

- 分页管理的地址空间是一维的, 分段的地址空间是二维的, 因为计算每个段的大小是不同的, 需要知道短号和段长度. 分页的话只需要知道页号即可.



#### 快表和多级页表?

在分页管理中虚拟地址到物理地址的转化要快, 同时还要解决虚拟地址空间大页表也会很大的问题

要解决虚拟地址到物理地址转换快的问题, 引入了快表机制, 快表是访问速度比内存快很多的高速缓存, 用来存放最近访问的页表项的副本, 可以大大加快地址变换速度. 它运用了局部性原理. 根据虚拟地址查询页表的时候首先去访问快表, 如果快表中有记录直接返回, 没有记录再去访问页表, 从页表中得到物理地址, 同时将映射添加到快表中.

为了解决虚拟地址空间太大导致页表过大的问题, 引入了多级页表. 多级页表将页表进行分页, 只在内存中驻留一级页表, 一级页表中的每个页表项指向二级页表基地址, 以此类推. 这是时间换空间的应用.



#### 逻辑地址(虚拟地址)和物理地址?

我们编程一般只会和逻辑地址打交道, 比如在 C 语言里面的指针就是逻辑地址, 逻辑地址由操作系统决定, 物理地址是真实的物理内存中的地址



#### 什么是虚拟内存?

虚拟内存是基于局部性原理, 将程序的一部分装入内存, 一部分驻留在外存, 需要的时候在将外存的内容调入内存, 从逻辑上扩充内存, 对程序而言, 看到的内存容量远大于实际的内存容量. 

它定义了一个连续的虚拟地址空间, 使编程的难度降低.在程序执行过程中，`当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存`，然后继续执行程序。`若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存`。

一个程序多次调入内存, 所以虚拟内存需要离散分配内存的方式支持



#### 虚拟内存技术如何实现?

请求分页管理: 在基础分页管理的基础上增加了请求调页和页面置换功能. 在作业开始运行之前, 仅装入当前要执行的一部分. 如果在访问过程中发生了缺页中断, 则由处理器通知操作系统按照页面置换算法将相应页面调入到主存. 

请求分段管理, 请求页段管理: 同样增加了请求调页和页面置换的功能.



#### 页面置换算法?

程序执行过程中, 当所访问的信息不在内存时, 由操作系统负责将所需的信息从外存调入内存, 然后继续执行程序. 若内存空间不够, 有操作系统负责将内存中暂时不用的信息调入到外存. 操作系统要提供页面置换的功能**.**



**最优置换算法(OPT)**

所选择的页面将是最长时间内不再被访问的页面, 通常可以获得最低的缺页率

是一种理论上的算法, 因为我们无法得知一个页面多长时间不再被访问	



**最近最少使用(LRU)**

虽然无法得知将来最长时间不再被访问的页面, 但是可以知道过去使用页面的情况, LRU 算法是将过去最久没有使用的页面置换出.

要实现 LRU 算法, 需要在内存中维护一个包含当前所有页面的链表, 当前访问一个页面时就将当前页面移到链表头部, 这样就能保证链表表尾是最近最久未访问的页面.

- 因为每次`访问`都要操作链表, 所以这种实现方式的 LRU 代价较高



**最少频率使用(NFU)**

给每个页面添加一个计数器, 初始为零, 每发生一次调用计数器加一, 发生缺页中断的时候将计数最小的一页置换出去 



**最近未使用(NRU)**

每个页面都设置一个访问位 R 和修改位 M, 当页面被访问时设置 R = 1, 当页面被修改时设置 M = 1. 其中 R 位会定时被清零. 可以将页面分为四类

R = 0, M = 0 : 没访问没修改

R = 0, M = 1 : 没访问被修改

R = 1, M = 0 : 访问被修改

R = 1, M = 1 : 访问没修改

当页面发生缺页中断时, NRU 算法随机的从`类编号最小的非空类`(即为 0 1)中挑选一个页面将它换出.

NRU 算法优先换出已经修改的脏页面(R = 0, M = 1), 而不是干净未修改的(R = 1, M = 0)

`但是 0 0 是最优先被置换的, 因为直接覆盖数据即可, 没有数据修改不用管一致性, 这样有极致的性能, 但是在 0 1 和 1 0 之间选择了先置换脏页 0 1. 因为没人访问, 虽然置换 1 0 快但是它近期被访问了 `



**先进先出算法(FIFO)**

每次淘汰的页是最早进入内存的页面, 将调入内存的页面根据调入顺序排成一个链表, 需要换出时将链表头页面弹出, 新页面加入链表尾部

FIFO 算法实现简单, 但是会将那些经常被访问的页面换出, 算法性能差



**第二次机会算法(SCR)**

它是对 FIFO 算法的修改, 置换时要检查队列头的 R 位是否为 0, 为 0 则置换, 不为 0 则将其 R 位改为 0 ,并插入链表尾部, 然后继续搜索

每次置换都要移动到链表尾部, 还可以优化 



**时钟算法(Clock)**

为了避免 SCR 算法中每次置换都要移动页面, 组织一个环形链表, 设置指针指向最早调入的页面, 当页面需要置换时当前指针指向页面的 R = 0, 则置换, 为 1 则将其 R 置为 0 后指针后移继续搜索



### Linux



#### Linux 常用命令?

**进程**

- top 命令: 实时显示进程的动态
  - top 按大写 H 切换是否显示线程
  - top -H -p <PID> 查看某个进程（PID）的所有线程
- ps -ef : 查看所有进程
  - ps -ef | grep redis : 查看特定的进程
- free -h : 查看内存情况

**搜索**

- grep 命令: 查找文件里符合条件的字符串`所在的行`
  - grep match : 文件中包含 match 的行
  - grep -n match : 显示行数
    - `应用: grep -n "2022-10-20 01:00:00" *.log : 显示某一时段的日志内容, 并拿到行数`
  - grep -c match : 符合条件的行数(不是个数, 一行出现两个算一行)

**创建文件&编辑**

- mkdir : 创建文件夹

- redir : 删除文件夹

- touch : 创建文件

- vim : 是一个文本编辑器

  默认是命令模式

  -a: 编辑模式

  :w: 保存

  :q: 退出

  esc: 退出编辑模式

**读文件**

- cat: 显示文件内容
- more 分页的显示文件内容, 适合大的文件
- less 和 more 相同但是多了向前翻页
- head -n 显示文件的前 n 行
- tail -n 显示文件的后 n 行

**复制&移动**

- cp 原目录 目的目录
- mv 源目录 目的目录
- pwd 命令: 打印工作目录
- cd 命令: 进入目录

**压缩**

- gzip : 



**网络状态**

- netstat : 查看网络状态

- netstat -a : 显示所有连接的 socket
- netstat -t : 显示所有 tcp socket
- netstat -u : 显示所有 udp socket
- netstat -p : 显示进程信息 : pid+进程名

```css
显示所有 tcp 连接的进程信息和 socket 信息
netstat -tp [| grep *]
```



**kill**

可用于删除执行中的程序, kill 将指定的信息送至程序, 默认是 15, 可将程序终止

kill -1 : 重新加载程序

kill -9 : 杀死一个程序

kill -15 : 正常停止一个程序